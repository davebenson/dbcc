/*
From http://www.quut.com/c/ANSI-C-grammar-y-2011.html
---------------------------------------------- BEGIN QUOTE
ANSI C Yacc grammar

(This Yacc file is accompanied by a matching Lex file.)

In 1985, Jeff Lee published his Yacc grammar based on a
draft version of the ANSI C standard, along with a
supporting Lex specification. Tom Stockfisch reposted those
files to net.sources in 1987; as mentioned in the answer to
question 17.25 of the comp.lang.c FAQ, they used to be
available from ftp.uu.net as
usenet/net.sources/ansi.c.grammar.Z.

The version you see here has been updated based on the 2011
ISO C standard. (The previous version's Lex and Yacc files
for ANSI C9X still exist as archived copies.)

This grammar assumes that translation phases 1..5 have
already been completed, including preprocessing and _Pragma
processing. The Lex rule for string literals will perform
concatenation (translation phase 6). Transliteration of
universal character names (\uHHHH or \UHHHHHHHH) must have
been done by either the preprocessor or a replacement for
the input() macro used by Lex (or the YY_INPUT function used
by Flex) to read characters. Although comments should have
been changed to space characters during translation phase 3,
there are Lex rules for them anyway.

I want to keep this version as close to the current C
Standard grammar as possible; please let me know if you
discover discrepancies.
(There is an FAQ for this grammar that you might want to read first.)

jutta@pobox.com, 2012

Last edit: 2012-12-18 DAGwyn@aol.com

Note: There are two shift/reduce conflicts, correctly resolved by default:
  IF LPAREN expression RPAREN statement _ ELSE statement
and
  ATOMIC _ LPAREN type_name RPAREN
where "_" has been used to flag the points of ambiguity.
---------------------------------------------- END QUOTE

ABOUT THIS LEMON GRAMMAR:

  * throughout, i've added "opt_ABC" non-terminal productions
    which have grammar:
        opt_ABC ::= .
        opt_ABC ::= ABC.

  * pointer are handled slightly differently, with
    each pointer-level being its own Declarator.

  * P_* types are used as intermediaries, but
    are not exposed outside the parser.  They are defined
    in this .lemon file.  They should match the grammar.

  * During parsing, we use a lot of linked lists,
    but we switch to arrays for the exported types.

ABOUT THE DIFFERENCES BETWEEN THE PARSING TYPES AND THE FINAL TYPES:

  * For various reasons, we use lists in the parsing structures,
    but we use arrays in the final code representations,
    which are prefixed with DBCC_ like DBCC_Expr, DBCC_Statement*, etc.

  * The P_* Types should never leak out of dbcc-lemon-p.lemon.

  * The most important change is that P_Declaration transforms
    into a list of DBCC_Declaration's, one for each declarator.
    This cleans up a lot of things.  The transformation expressed
    in C looks like this: start with:
       int foo = 42, *xyz = NULL, bar(int xxx);
    it becomes:
       int foo = 42;
       int *xyz = NULL;
       typedef int (*TMP)(int xxx);
       TMP bar;
    XXXX: where does the TMP deref/ref happen ???

 */

%name DBCC_Lemon_Parser

%syntax_error{
  (void) yymajor;
  (void) yyminor;
}

%include {

#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include "dbcc.h"
#include "p-token.h"
#include "dbcc-statement-internal.h"

/* This declares the functions defined in the code generated by lemon.
 * It is included so we will get an error if a function is mis-defined.
 */
#include "dbcc-parser-lemon.h"

typedef struct P_DeclaratorList P_DeclaratorList;
typedef struct P_DeclarationList P_DeclarationList;
typedef struct P_ParameterList P_ParameterList;
typedef struct P_Declarator P_Declarator;
typedef struct P_Declaration P_Declaration;
typedef struct P_DesignatorList P_DesignatorList;
typedef struct P_Designator P_Designator;

typedef struct P_AlignmentSpecifier P_AlignmentSpecifier;
typedef struct P_Initializer P_Initializer;
typedef struct P_InitializerList P_InitializerList;

typedef struct P_GenericAssociationList P_GenericAssociationList;
typedef struct P_GenericAssociation P_GenericAssociation;

#define FAIL()                       \
  do{                                \
    assert(context->error != NULL);  \
    return;                          \
  }while(0)

#if 0
static inline char *
token_strdup (P_Token *t)
{
  char *rv = malloc (t->length + 1);
  memcpy (rv, t->str, t->length);
  rv[t->length] = 0;
  return rv;
}
#endif

/* Forward declarations of various internal functions */
static bool declaration_list_to_params (P_Context *context, 
                                        P_DeclarationList *list,
                                        size_t *n_params_out,
                                        DBCC_Param **params_out);
static void p_declaration_list_clear (P_DeclarationList *list);

struct P_Context
{
  DBCC_Error *error;
  DBCC_Namespace *globals;
  DBCC_Namespace *locals;
  DBCC_TargetEnvironment *target_env;
  int next_enum_value;
};
#define P_CONTEXT_NAMESPACE(context) \
        ((context)->locals ? (context)->locals : (context)->globals)

#define CONTEXT_NS     P_CONTEXT_NAMESPACE(context)

typedef struct 
{
  unsigned n_ptr;
  DBCC_TypeQualifier *ptr_type_qualifiers;
  DBCC_CodePosition *code_position;
} P_Pointer;
static bool
p_context_lookup (P_Context *context,
                  DBCC_Symbol *symbol,
                  DBCC_CodePosition *cp,
                  DBCC_NamespaceEntry *entry)
{
  if (!dbcc_namespace_lookup (CONTEXT_NS, symbol, entry))
    {
      context->error = dbcc_error_new (DBCC_ERROR_NOT_FOUND,
                                       "symbol '%s' not found",
                                       dbcc_symbol_get_string(symbol));
      if (cp != NULL)
        dbcc_error_add_code_position (context->error, cp);
      return false;
    }
  return true;
}

static DBCC_Type *
context_new_struct_stub (P_Context         *context,
                         DBCC_Symbol       *tag,
                         DBCC_CodePosition *cp)
{
  DBCC_Namespace *ns = CONTEXT_NS;
  (void) cp;
  DBCC_Type *rv = dbcc_namespace_lookup_struct_tag (ns, tag);
  if (rv != NULL)
    return rv;
  rv = dbcc_type_new_incomplete_struct (tag);
  dbcc_namespace_add_by_tag (ns, rv);
  return rv;
}
static DBCC_Type *
context_new_union_stub  (P_Context         *context,
                         DBCC_Symbol       *tag,
                         DBCC_CodePosition *cp)
{
  DBCC_Namespace *ns = CONTEXT_NS;
  DBCC_Type *rv = dbcc_namespace_lookup_union_tag (ns, tag);
  (void) cp;
  if (rv != NULL)
    return rv;
  rv = dbcc_type_new_incomplete_union (tag);
  dbcc_namespace_add_by_tag (ns, rv);
  return rv;
}

static DBCC_Type *
context_new_struct               (P_Context         *context,
                                  DBCC_Symbol       *tag,
                                  DBCC_CodePosition *cp,
                                  size_t             n_params,
                                  DBCC_Param        *params)
{
  DBCC_Type *rv;
  DBCC_Namespace *ns = CONTEXT_NS;
  rv = dbcc_namespace_lookup_struct_tag (ns, tag);
  if (rv != NULL)
    {
      if (!rv->v_struct.incomplete)
        {
          context->error = dbcc_error_new (DBCC_ERROR_MULTIPLE_DEFINITION,
                                           "struct %s multiply defined",
                                           dbcc_symbol_get_string (tag));
          dbcc_error_add_code_position (context->error, cp);
          return NULL;
        }
      if (!dbcc_type_complete_struct (context->target_env, rv, n_params, params, &context->error))
        {
          dbcc_error_add_code_position (context->error, cp);
          return NULL;
        }
    }
  else
    {
      rv = dbcc_type_new_struct (context->target_env,
                                 tag,
                                 n_params, params,
                                 &context->error);
      if (rv == NULL)
        {
          dbcc_error_add_code_position (context->error, cp);
          return NULL;
        }
      dbcc_namespace_add_by_tag (ns, rv);
    }
  return rv;
}
static DBCC_Type *
context_new_union               (P_Context         *context,
                                 DBCC_Symbol       *tag,
                                 DBCC_CodePosition *cp,
                                 size_t             n_params,
                                 DBCC_Param        *params)

{
  DBCC_Type *rv;
  DBCC_Namespace *ns = CONTEXT_NS;
  rv = dbcc_namespace_lookup_union_tag (ns, tag);
  if (rv != NULL)
    {
      if (!rv->v_struct.incomplete)
        {
          context->error = dbcc_error_new (DBCC_ERROR_MULTIPLE_DEFINITION,
                                           "union %s multiply defined",
                                           dbcc_symbol_get_string (tag));
          dbcc_error_add_code_position (context->error, cp);
          return NULL;
        }
      if (!dbcc_type_complete_union (context->target_env,
                                     rv,
                                     n_params, params,
                                     &context->error))
        {
          dbcc_error_add_code_position (context->error, cp);
          return NULL;
        }
    }
  else
    {
      rv = dbcc_type_new_union (context->target_env,
                                tag, n_params, params,
                                &context->error);
      if (rv == NULL)
        {
          dbcc_error_add_code_position (context->error, cp);
          return NULL;
        }
      dbcc_namespace_add_by_tag (ns, rv);
    }
  return rv;
}

P_Context *
p_context_new (DBCC_Namespace *ns)
{
  P_Context *rv = malloc (sizeof (P_Context));
  rv->error = NULL;
  rv->globals = ns;
  rv->locals = NULL;
  return rv;
}

#if 0
static void
p_context_add_enum_value (P_Context *context,
                          DBCC_EnumValue *enum_value)
{
  DBCC_Namespace *ns = context->locals ? context->locals : context->globals;
  dbcc_namespace_add_enum_value (ns, enum_value);
}
#endif

struct P_DesignatorList
{
  P_Designator *first, *last;
};
  
typedef enum
{
  P_ALIGNMENT_SPECIFIER_BY_TYPE,
  P_ALIGNMENT_SPECIFIER_BY_EXPR
} P_AlignmentSpecifierType;
struct P_AlignmentSpecifier
{
  P_AlignmentSpecifierType specifier_type;
  union {
    DBCC_Type *v_type;
    DBCC_Expr *v_expr;
  };
};


typedef enum
{
  P_INITIALIZER_TYPE_EXPR,
  P_INITIALIZER_TYPE_STRUCTURED
} P_InitializerType;

struct P_InitializerList
{
  P_Initializer *first;
  P_Initializer *last;
};

struct P_Initializer
{
  P_DesignatorList designators;
  P_InitializerType initializer_type;
  P_Initializer *next;
  union {
    DBCC_Expr *v_expr;
    P_InitializerList v_structured;               // for objects and arrays
  };
};
static P_Initializer *
p_initializer_new_expr (DBCC_Expr *expr)
{
  P_Initializer *rv = malloc (sizeof(P_Initializer));
  rv->designators.first = NULL;
  rv->designators.last = NULL;
  rv->initializer_type = P_INITIALIZER_TYPE_EXPR;
  rv->next = NULL;
  rv->v_expr = expr;
  return rv;
}
static P_Initializer *
p_initializer_new_structured (P_InitializerList *list)
{
  P_Initializer *rv = malloc (sizeof(P_Initializer));
  rv->designators.first = NULL;
  rv->designators.last = NULL;
  rv->initializer_type = P_INITIALIZER_TYPE_STRUCTURED;
  rv->next = NULL;
  rv->v_structured = *list;
  return rv;
}
static void p_initializer_list_clear(P_InitializerList *list);
static void
p_initializer_destroy (P_Initializer *p)
{
  switch (p->initializer_type)
    {
    case P_INITIALIZER_TYPE_EXPR:
      dbcc_expr_destroy (p->v_expr);
      break;
    case P_INITIALIZER_TYPE_STRUCTURED:
      p_initializer_list_clear (&p->v_structured);
      break;
    }
  free (p);
}
static void p_initializer_list_clear(P_InitializerList *list)
{
  while (list->first != NULL)
    {
      P_Initializer *kill = list->first;
      list->first = kill->next;
      p_initializer_destroy (kill);
    }
  list->last = NULL;
}

typedef struct P_EnumValueNode P_EnumValueNode;
typedef struct P_EnumValueList P_EnumValueList;
struct P_EnumValueList
{
  P_EnumValueNode *first, *last;
};

struct P_EnumValueNode
{
  P_EnumValueNode *next;
  DBCC_EnumValue *enum_value;
};
static void
p_enumerator_list_clear (P_EnumValueList *list)
{
  while (list->first != NULL)
    {
      P_EnumValueNode *kill = list->first;
      list->first = kill->next;
      free (kill);
    }
  list->last = NULL;
}


typedef struct P_IdentifierList P_IdentifierList;
typedef struct P_IdentifierNode P_IdentifierNode;
struct P_IdentifierList
{
  P_IdentifierNode *first, *last;
};
struct P_IdentifierNode
{
  DBCC_Symbol *identifier;
  P_IdentifierNode *prev, *next;
};
static void p_identifier_node_destroy(P_IdentifierNode *node) { free(node); }
static void
p_identifier_list_clear (P_IdentifierList *list)
{
  while (list->first != NULL)
    {
      P_IdentifierNode *kill = list->first;
      list->first = kill->next;
      p_identifier_node_destroy (kill);
    }
  list->last = NULL;
}
static void
p_identifier_list_append (P_IdentifierList *list, DBCC_Symbol *identifier)
{
  P_IdentifierNode *node = malloc (sizeof (P_IdentifierNode));
  if (list->first)
    list->last->next = node;
  else
    list->first = node;
  list->last = node;
  node->identifier = identifier;
  node->next = NULL;
}


struct P_GenericAssociationList
{
  P_GenericAssociation *first, *last;
};
struct P_GenericAssociation
{
  P_GenericAssociation *next;
  DBCC_Type *type;
  DBCC_Expr *expr;
};
static P_GenericAssociation *
p_generic_association_new (DBCC_Type *type, DBCC_Expr *expr)
{
  P_GenericAssociation *rv = malloc (sizeof (P_GenericAssociation));
  rv->next = NULL;
  rv->type = type;
  rv->expr = expr;
  return rv;
}
static void p_generic_association_destroy (P_GenericAssociation *ga)
{
  dbcc_type_unref (ga->type);
  dbcc_expr_destroy (ga->expr);
  free (ga);
}
static void p_generic_association_list_clear (P_GenericAssociationList *list)
{
  while (list->first != NULL)
    {
      P_GenericAssociation *kill = list->first;
      list->first = kill->next;
      p_generic_association_destroy (kill);
    }
  list->last = NULL;
}

struct P_DeclarationList
{
  P_Declaration *first_declaration;
  P_Declaration *last_declaration;
};

struct P_ParameterList
{
  P_DeclarationList parameters;
  bool has_varargs;
};
struct P_DeclaratorList
{
  P_Declarator *first_declarator;
  P_Declarator *last_declarator;
};
typedef enum
{
  P_DECLARATION_TYPE_DECLARATION,
  P_DECLARATION_TYPE_STATIC_ASSERT,
} P_DeclarationType;


typedef enum
{
  P_DECLARATOR_TYPE_NAME,
  P_DECLARATOR_TYPE_POINTER,
  P_DECLARATOR_TYPE_ARRAY,
  P_DECLARATOR_TYPE_VARLEN_ARRAY,
  P_DECLARATOR_TYPE_BITFIELD,
  P_DECLARATOR_TYPE_FUNCTION,
  P_DECLARATOR_TYPE_KR_FUNCTION,
  P_DECLARATOR_TYPE_PARENTHESIZED       // usually ignored; distinguishes return-value and name in function-type declarators
} P_DeclaratorType;

struct P_Declarator
{
  P_DeclaratorType declarator_type;
  P_Declarator *prev, *next;            // only for toplevel declarator
  DBCC_CodePosition *code_position;
  union {
    DBCC_Symbol *v_name;
    struct {
      DBCC_TypeQualifier qualifiers;
      P_Declarator *target;
    } v_pointer;
    struct {
      DBCC_TypeQualifier qualifiers;
      P_Declarator *child;
      DBCC_Expr *size;
    } v_array;
    struct {
      DBCC_TypeQualifier qualifiers;
      P_Declarator *child;
    } v_varlen_array;
    struct {
      P_Declarator *child;
      DBCC_Expr *bit_width;
    } v_bitfield;
    struct {
      P_Declarator *child;
      P_ParameterList parameters;
    } v_function;
    struct {
      P_Declarator *child;
      P_IdentifierList parameters;
    } v_kr_function;
    struct {
      P_Declarator *child;
    } v_parenthesized;
  };
  P_Initializer *initializer;
};
typedef enum
{
  P_TYPE_SPECIFIERS_INDEX_VOID      = 0,
  P_TYPE_SPECIFIERS_INDEX_CHAR      = 1,
  P_TYPE_SPECIFIERS_INDEX_INT       = 2,
  P_TYPE_SPECIFIERS_INDEX_SHORT     = 3,
  P_TYPE_SPECIFIERS_INDEX_LONG      = 4,
  P_TYPE_SPECIFIERS_INDEX_UNSIGNED  = 5,
  P_TYPE_SPECIFIERS_INDEX_SIGNED    = 6,
  P_TYPE_SPECIFIERS_INDEX_FLOAT     = 7,
  P_TYPE_SPECIFIERS_INDEX_DOUBLE    = 8,
  P_TYPE_SPECIFIERS_INDEX_BOOL      = 9,
  P_TYPE_SPECIFIERS_INDEX_ATOMIC    = 10,
  P_TYPE_SPECIFIERS_INDEX_COMPLEX   = 11,
  P_TYPE_SPECIFIERS_INDEX_IMAGINARY = 12,
  P_TYPE_SPECIFIERS_INDEX_TYPEDEF   = 13,
  P_TYPE_SPECIFIERS_INDEX_STRUCT    = 14,
  P_TYPE_SPECIFIERS_INDEX_UNION     = 15,
  P_TYPE_SPECIFIERS_INDEX_ENUM      = 16
} P_TypeSpecifiersIndex;
#define N_TYPE_SPECIFIER_KEYWORDS     17
#define P_TYPE_SPECIFIER_KEYWORD_FOREACH(macro) \
  macro(VOID)       \
  macro(CHAR)       \
  macro(INT)        \
  macro(SHORT)      \
  macro(LONG)       \
  macro(UNSIGNED)   \
  macro(SIGNED)     \
  macro(FLOAT)      \
  macro(DOUBLE)     \
  macro(BOOL)       \
  macro(ATOMIC)     \
  macro(COMPLEX)    \
  macro(IMAGINARY)  \
  macro(TYPEDEF)    \
  macro(STRUCT)     \
  macro(UNION)      \
  macro(ENUM)

static uint8_t max_instances_of_counts[N_TYPE_SPECIFIER_KEYWORDS] =
{
  1,
  1,
  1,
  1,
  2,            // long long is allowed, the only allowed repeated keyword
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
};
#define CONFLICTS_WITH(type1, braced_list) \
static P_TypeSpecifiersIndex conflicts_with_##type1[] = braced_list;
#define TYPE_SPECIFIERS_LIST(...) { __VA_ARGS__ }

CONFLICTS_WITH(VOID, TYPE_SPECIFIERS_LIST(
  P_TYPE_SPECIFIERS_INDEX_CHAR,
  P_TYPE_SPECIFIERS_INDEX_INT,
  P_TYPE_SPECIFIERS_INDEX_SHORT,
  P_TYPE_SPECIFIERS_INDEX_LONG,
  P_TYPE_SPECIFIERS_INDEX_UNSIGNED,
  P_TYPE_SPECIFIERS_INDEX_SIGNED,
  P_TYPE_SPECIFIERS_INDEX_FLOAT,
  P_TYPE_SPECIFIERS_INDEX_DOUBLE,
  P_TYPE_SPECIFIERS_INDEX_BOOL,
  P_TYPE_SPECIFIERS_INDEX_COMPLEX,
  P_TYPE_SPECIFIERS_INDEX_IMAGINARY,
  P_TYPE_SPECIFIERS_INDEX_TYPEDEF,
  P_TYPE_SPECIFIERS_INDEX_STRUCT,
  P_TYPE_SPECIFIERS_INDEX_UNION,
  P_TYPE_SPECIFIERS_INDEX_ENUM
  ))
CONFLICTS_WITH(CHAR, TYPE_SPECIFIERS_LIST(
  P_TYPE_SPECIFIERS_INDEX_INT,
  P_TYPE_SPECIFIERS_INDEX_SHORT,
  P_TYPE_SPECIFIERS_INDEX_LONG,
  P_TYPE_SPECIFIERS_INDEX_FLOAT,
  P_TYPE_SPECIFIERS_INDEX_DOUBLE,
  P_TYPE_SPECIFIERS_INDEX_BOOL,
  P_TYPE_SPECIFIERS_INDEX_TYPEDEF,
  P_TYPE_SPECIFIERS_INDEX_STRUCT,
  P_TYPE_SPECIFIERS_INDEX_UNION,
  P_TYPE_SPECIFIERS_INDEX_ENUM
))
CONFLICTS_WITH(INT, TYPE_SPECIFIERS_LIST(
  P_TYPE_SPECIFIERS_INDEX_FLOAT,
  P_TYPE_SPECIFIERS_INDEX_DOUBLE,
  P_TYPE_SPECIFIERS_INDEX_BOOL,
  P_TYPE_SPECIFIERS_INDEX_TYPEDEF,
  P_TYPE_SPECIFIERS_INDEX_STRUCT,
  P_TYPE_SPECIFIERS_INDEX_UNION,
  P_TYPE_SPECIFIERS_INDEX_ENUM
))
CONFLICTS_WITH(SHORT, TYPE_SPECIFIERS_LIST(
  P_TYPE_SPECIFIERS_INDEX_LONG,
  P_TYPE_SPECIFIERS_INDEX_FLOAT,
  P_TYPE_SPECIFIERS_INDEX_DOUBLE,
  P_TYPE_SPECIFIERS_INDEX_BOOL,
  P_TYPE_SPECIFIERS_INDEX_TYPEDEF,
  P_TYPE_SPECIFIERS_INDEX_STRUCT,
  P_TYPE_SPECIFIERS_INDEX_UNION,
  P_TYPE_SPECIFIERS_INDEX_ENUM
))
CONFLICTS_WITH(LONG, TYPE_SPECIFIERS_LIST(
  P_TYPE_SPECIFIERS_INDEX_FLOAT,
  P_TYPE_SPECIFIERS_INDEX_BOOL,
  P_TYPE_SPECIFIERS_INDEX_TYPEDEF,
  P_TYPE_SPECIFIERS_INDEX_STRUCT,
  P_TYPE_SPECIFIERS_INDEX_UNION,
  P_TYPE_SPECIFIERS_INDEX_ENUM
))
CONFLICTS_WITH(FLOAT, TYPE_SPECIFIERS_LIST(
  P_TYPE_SPECIFIERS_INDEX_SIGNED,
  P_TYPE_SPECIFIERS_INDEX_UNSIGNED,
  P_TYPE_SPECIFIERS_INDEX_DOUBLE,
  P_TYPE_SPECIFIERS_INDEX_BOOL,
  P_TYPE_SPECIFIERS_INDEX_TYPEDEF,
  P_TYPE_SPECIFIERS_INDEX_STRUCT,
  P_TYPE_SPECIFIERS_INDEX_UNION,
  P_TYPE_SPECIFIERS_INDEX_ENUM
))
CONFLICTS_WITH(DOUBLE, TYPE_SPECIFIERS_LIST(
  P_TYPE_SPECIFIERS_INDEX_SIGNED,
  P_TYPE_SPECIFIERS_INDEX_UNSIGNED,
  P_TYPE_SPECIFIERS_INDEX_BOOL,
  P_TYPE_SPECIFIERS_INDEX_TYPEDEF,
  P_TYPE_SPECIFIERS_INDEX_STRUCT,
  P_TYPE_SPECIFIERS_INDEX_UNION,
  P_TYPE_SPECIFIERS_INDEX_ENUM
))
CONFLICTS_WITH(SIGNED, TYPE_SPECIFIERS_LIST(
  P_TYPE_SPECIFIERS_INDEX_UNSIGNED,
  P_TYPE_SPECIFIERS_INDEX_TYPEDEF,
  P_TYPE_SPECIFIERS_INDEX_STRUCT,
  P_TYPE_SPECIFIERS_INDEX_UNION,
  P_TYPE_SPECIFIERS_INDEX_ENUM
))
CONFLICTS_WITH(UNSIGNED, TYPE_SPECIFIERS_LIST(
  P_TYPE_SPECIFIERS_INDEX_SIGNED,
  P_TYPE_SPECIFIERS_INDEX_TYPEDEF,
  P_TYPE_SPECIFIERS_INDEX_STRUCT,
  P_TYPE_SPECIFIERS_INDEX_UNION,
  P_TYPE_SPECIFIERS_INDEX_ENUM
))
CONFLICTS_WITH(BOOL, TYPE_SPECIFIERS_LIST(
  P_TYPE_SPECIFIERS_INDEX_COMPLEX,
  P_TYPE_SPECIFIERS_INDEX_IMAGINARY,
  P_TYPE_SPECIFIERS_INDEX_TYPEDEF,
  P_TYPE_SPECIFIERS_INDEX_STRUCT,
  P_TYPE_SPECIFIERS_INDEX_UNION,
  P_TYPE_SPECIFIERS_INDEX_ENUM
))
CONFLICTS_WITH(COMPLEX, TYPE_SPECIFIERS_LIST(
  P_TYPE_SPECIFIERS_INDEX_IMAGINARY,
  P_TYPE_SPECIFIERS_INDEX_TYPEDEF,
  P_TYPE_SPECIFIERS_INDEX_STRUCT,
  P_TYPE_SPECIFIERS_INDEX_UNION,
  P_TYPE_SPECIFIERS_INDEX_ENUM
))
CONFLICTS_WITH(IMAGINARY, TYPE_SPECIFIERS_LIST(
  P_TYPE_SPECIFIERS_INDEX_TYPEDEF,
  P_TYPE_SPECIFIERS_INDEX_STRUCT,
  P_TYPE_SPECIFIERS_INDEX_UNION,
  P_TYPE_SPECIFIERS_INDEX_ENUM
))
CONFLICTS_WITH(ATOMIC, TYPE_SPECIFIERS_LIST())
CONFLICTS_WITH(TYPEDEF, TYPE_SPECIFIERS_LIST(
  P_TYPE_SPECIFIERS_INDEX_STRUCT,
  P_TYPE_SPECIFIERS_INDEX_UNION,
  P_TYPE_SPECIFIERS_INDEX_ENUM
))
CONFLICTS_WITH(STRUCT, TYPE_SPECIFIERS_LIST(
  P_TYPE_SPECIFIERS_INDEX_UNION,
  P_TYPE_SPECIFIERS_INDEX_ENUM
))
CONFLICTS_WITH(UNION, TYPE_SPECIFIERS_LIST(
  P_TYPE_SPECIFIERS_INDEX_ENUM
))
CONFLICTS_WITH(ENUM, TYPE_SPECIFIERS_LIST())
static struct { size_t n_conflicts;
                P_TypeSpecifiersIndex *conflicts; } conflict_table[N_TYPE_SPECIFIER_KEYWORDS] =
{
#define emit_conflict_table_entry(shortname) \
  { sizeof(conflicts_with_##shortname)/sizeof(conflicts_with_##shortname[0]), \
    conflicts_with_##shortname },
  P_TYPE_SPECIFIER_KEYWORD_FOREACH(emit_conflict_table_entry)
};
#undef emit_conflict_table_entry


static const char *
count_index_to_keyword (unsigned i)
{
  switch (i)
    {
    case P_TYPE_SPECIFIERS_INDEX_VOID: return "void";
    case P_TYPE_SPECIFIERS_INDEX_CHAR: return "char";
    case P_TYPE_SPECIFIERS_INDEX_INT: return "int";
    case P_TYPE_SPECIFIERS_INDEX_SHORT: return "short";
    case P_TYPE_SPECIFIERS_INDEX_LONG: return "long";
    case P_TYPE_SPECIFIERS_INDEX_UNSIGNED: return "unsigned";
    case P_TYPE_SPECIFIERS_INDEX_SIGNED: return "signed";
    case P_TYPE_SPECIFIERS_INDEX_FLOAT: return "float";
    case P_TYPE_SPECIFIERS_INDEX_DOUBLE: return "double";
    case P_TYPE_SPECIFIERS_INDEX_BOOL: return "bool";
    case P_TYPE_SPECIFIERS_INDEX_ATOMIC: return "_Atomic";
    case P_TYPE_SPECIFIERS_INDEX_COMPLEX: return "_Complex";
    case P_TYPE_SPECIFIERS_INDEX_IMAGINARY: return "_Imaginary";
    case P_TYPE_SPECIFIERS_INDEX_TYPEDEF: return "typedef";
    case P_TYPE_SPECIFIERS_INDEX_STRUCT: return "struct";
    case P_TYPE_SPECIFIERS_INDEX_UNION: return "union";
    case P_TYPE_SPECIFIERS_INDEX_ENUM: return "enum";
    default: return "unknSown-type-specifier";
    }
}

typedef struct
{
  uint8_t counts[N_TYPE_SPECIFIER_KEYWORDS];
  DBCC_Symbol *symbol;
  DBCC_Symbol *id;              // for named structs, unions, enums
  bool is_stub;                 // for forward-declared structs+unions+enums

  // for enum, atomic, typedef, struct, union: this is the actual (un-qualified) tyype)
  DBCC_Type *type;              
} P_TypeSpecifiers;

#define P_TYPE_SPECIFIERS_INIT \
    (P_TypeSpecifiers) \
        {{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},NULL,NULL,false,NULL}

static bool
p_type_specifiers_combine (P_Context *context,
                           P_TypeSpecifiers *in_out,
                           P_TypeSpecifiers *modifier)
{
  for (unsigned i = 0; i < N_TYPE_SPECIFIER_KEYWORDS; i++)
    {
      uint8_t sum = in_out->counts[i] + modifier->counts[i];
      if (sum < in_out->counts[i]
       || sum > max_instances_of_counts[i])
        {
          context->error = dbcc_error_new (DBCC_ERROR_TOO_MANY_TYPE_SPECIFIERS,
                                           "too many repeated qualifiers: at %s",
                                           count_index_to_keyword (i));
          return false;
        }
      in_out->counts[i] = sum;
    }
  for (unsigned i = 0; i < N_TYPE_SPECIFIER_KEYWORDS; i++)
    if (in_out->counts[i] != 0)
      {
        unsigned nc = conflict_table[i].n_conflicts;
        const P_TypeSpecifiersIndex *c = conflict_table[i].conflicts;
        for (unsigned j = 0; j < nc; j++)
          if (in_out->counts[c[j]] != 0)
            {
              context->error = dbcc_error_new (DBCC_ERROR_CONFLICTING_QUALIFIERS,
                                               "'%s' is not allowed with '%s'",
                                               count_index_to_keyword (i),
                                               count_index_to_keyword (c[j]));
              return false;
            }
      }
  return true;
}

#if 0
static bool
p_type_specifiers_init_struct_or_union
                              (P_TypeSpecifiers  *to_init,
                               P_Context         *context,
                               bool               is_struct,   // else union
                               DBCC_Symbol       *opt_tag,
                               P_DeclarationList *declaration_list)
{
  P_TypeSpecifiers rv = P_TYPE_SPECIFIERS_INIT;
  rv.symbol = opt_tag;
  rv.counts[P_TYPE_SPECIFIERS_INDEX_STRUCT] = 1;
  
  size_t n_params;
  DBCC_Param *params;

  if (!declaration_list_to_params (context, declaration_list, &n_params, &params))
    return false;

  if (is_struct)
    to_init->type = dbcc_type_new_struct (opt_tag, n_params, params, &context->error);
  else
    to_init->type = dbcc_type_new_union (opt_tag, n_params, params, &context->error);

  return to_init->type != NULL;
}
#endif

static void
p_type_specifiers_clear (P_TypeSpecifiers *ts)
{
  (void) ts;
  //if (ts->type != NULL)
    //dbcc_type_unref (ts->type);
}

struct P_Declaration
{
  P_DeclarationType type;
  P_Declaration *next;
  union {
    struct {
      DBCC_StorageClassSpecifier storage_class_specifiers;
      DBCC_FunctionSpecifiers function_specifiers;
      DBCC_TypeQualifier qualifiers;
      P_AlignmentSpecifier *alignment_specifier;
      P_TypeSpecifiers specifiers;
      P_DeclaratorList declarators;
      DBCC_Statement *body;             // for functions (which must be a the sole declarator)
    } v_declaration;
    struct {
      DBCC_Expr *constant_expr;
      DBCC_String message;
    } v_static_assertion;
  };
};

static P_Declaration *
p_declaration_new (void)
{
  P_Declaration *rv = malloc (sizeof (P_Declaration));
  rv->type = P_DECLARATION_TYPE_DECLARATION;
  rv->next = NULL;
  rv->v_declaration.qualifiers = 0;
  rv->v_declaration.storage_class_specifiers = 0;
  rv->v_declaration.function_specifiers = 0;
  rv->v_declaration.specifiers = P_TYPE_SPECIFIERS_INIT;
  rv->v_declaration.declarators.first_declarator = NULL;
  rv->v_declaration.declarators.last_declarator = NULL;
  return rv;
}
static P_Declaration *
p_static_assertion_new (DBCC_Expr *expr, DBCC_String *explanation)
{
  P_Declaration *rv = malloc (sizeof (P_Declaration));
  rv->type = P_DECLARATION_TYPE_STATIC_ASSERT;
  rv->next = NULL;
  rv->v_static_assertion.constant_expr = expr;
  rv->v_static_assertion.message = *explanation;
  return rv;
}

static P_Declarator *
p_declarator_new_pointer (DBCC_TypeQualifier qualifiers,
                          P_Declarator *child,
                          DBCC_CodePosition *cp)
{
  P_Declarator *rv = malloc (sizeof(P_Declarator));
  rv->declarator_type = P_DECLARATOR_TYPE_POINTER;
  rv->code_position = cp;
  rv->prev = rv->next = NULL;
  rv->v_pointer.qualifiers = qualifiers;
  rv->v_pointer.target = child;
  rv->initializer = NULL;
  return rv;
}

static P_Declarator *
p_declarator_new_array   (DBCC_TypeQualifier qualifiers,
                          DBCC_Expr    *size,
                          P_Declarator *child)
{
  P_Declarator *rv = malloc (sizeof(P_Declarator));
  rv->declarator_type = P_DECLARATOR_TYPE_ARRAY;
  rv->code_position = dbcc_code_position_ref (child->code_position);
  rv->prev = rv->next = NULL;
  rv->v_array.qualifiers = qualifiers;
  rv->v_array.child = child;
  rv->v_array.size = size;
  rv->initializer = NULL;
  return rv;
}

static P_Declarator *
p_declarator_new_varlen_array   (DBCC_TypeQualifier qualifiers,
                                 P_Declarator *child)
{
  P_Declarator *rv = malloc (sizeof(P_Declarator));
  rv->declarator_type = P_DECLARATOR_TYPE_VARLEN_ARRAY;
  rv->prev = rv->next = NULL;
  rv->v_varlen_array.qualifiers = qualifiers;
  rv->v_varlen_array.child = child;
  rv->initializer = NULL;
  return rv;
}

static P_Declarator *
p_declarator_new_name    (DBCC_Symbol  *symbol)
{
  P_Declarator *rv = malloc (sizeof(P_Declarator));
  rv->declarator_type = P_DECLARATOR_TYPE_NAME;
  rv->prev = rv->next = NULL;
  rv->v_name = symbol;
  rv->initializer = NULL;
  return rv;
}

static P_Declarator *
p_declarator_new_bitfield    (P_Declarator *child,
                              DBCC_Expr    *bit_width)
{
  P_Declarator *rv = malloc (sizeof(P_Declarator));
  rv->declarator_type = P_DECLARATOR_TYPE_BITFIELD;
  rv->next = NULL;
  rv->v_bitfield.bit_width = bit_width;
  rv->v_bitfield.child = child;
  rv->initializer = NULL;
  return rv;
}

static P_Declarator *
p_declarator_new_function    (P_Declarator *child,
                              P_ParameterList *args)
{
  P_Declarator *rv = malloc (sizeof(P_Declarator));
  rv->declarator_type = P_DECLARATOR_TYPE_FUNCTION;
  rv->next = NULL;
  if (args != NULL)
    rv->v_function.parameters = *args;
  else
    {
      rv->v_function.parameters.parameters.first_declaration = NULL;
      rv->v_function.parameters.parameters.last_declaration = NULL;
      rv->v_function.parameters.has_varargs = false;
    }
  rv->v_function.child = child;
  rv->initializer = NULL;
  return rv;
}
static P_Declarator *
p_declarator_new_function_kr (P_Declarator *child,
                              P_IdentifierList *args)
{
  P_Declarator *rv = malloc (sizeof(P_Declarator));
  rv->declarator_type = P_DECLARATOR_TYPE_KR_FUNCTION;
  rv->next = NULL;
  if (args != NULL)
    {
      rv->v_kr_function.parameters = *args;
    }
  else
    {
      rv->v_kr_function.parameters.first = NULL;
      rv->v_kr_function.parameters.last = NULL;
    }
  rv->v_function.child = child;
  rv->initializer = NULL;
  return rv;
}



static void
p_declarator_destroy     (P_Declarator *d)
{
  switch (d->declarator_type)
    {
    case P_DECLARATOR_TYPE_POINTER:
      p_declarator_destroy (d->v_pointer.target);
      break;
    case P_DECLARATOR_TYPE_ARRAY:
      p_declarator_destroy (d->v_array.child);
      dbcc_expr_destroy (d->v_array.size);
      break;
    case P_DECLARATOR_TYPE_VARLEN_ARRAY:
      p_declarator_destroy (d->v_varlen_array.child);
      break;
    case P_DECLARATOR_TYPE_NAME:
      break;
    default:
      assert(0);
    }
  free (d);
}


static void
p_declaration_append_declarator (P_Declaration *parent,
                                 P_Declarator  *child)
{
  assert(parent->type == P_DECLARATION_TYPE_DECLARATION);
  if (parent->v_declaration.declarators.first_declarator == NULL)
    parent->v_declaration.declarators.first_declarator = child;
  else
    parent->v_declaration.declarators.last_declarator->next = child;
  parent->v_declaration.declarators.last_declarator = child;
  child->next = NULL;
}

static void p_declarator_list_clear (P_DeclaratorList *list);
static void p_declaration_destroy (P_Declaration *decl)
{
  switch (decl->type)
    {
    case P_DECLARATION_TYPE_STATIC_ASSERT:
      dbcc_expr_destroy (decl->v_static_assertion.constant_expr);
      dbcc_string_clear (&decl->v_static_assertion.message);
      break;
    case P_DECLARATION_TYPE_DECLARATION:
      p_type_specifiers_clear (&decl->v_declaration.specifiers);
      p_declarator_list_clear (&decl->v_declaration.declarators);
      break;
    default:
      assert(0);
    }
  free (decl);
}
static void
p_declaration_list_clear (P_DeclarationList *list)
{
  while (list->first_declaration != NULL)
    {
      P_Declaration *kill = list->first_declaration;
      list->first_declaration = kill->next;
      p_declaration_destroy (kill);
    }
  list->last_declaration = NULL;
}
static void
p_declarator_list_clear (P_DeclaratorList *list)
{
  while (list->first_declarator != NULL)
    {
      P_Declarator *kill = list->first_declarator;
      list->first_declarator = kill->next;
      p_declarator_destroy (kill);
    }
  list->last_declarator = NULL;
}
static void
p_parameter_list_clear (P_ParameterList *list)
{
  p_declaration_list_clear(&list->parameters);
}

typedef struct P_ExprList P_ExprList;
typedef struct P_ExprNode P_ExprNode;
struct P_ExprList
{
  P_ExprNode *first, *last;
};
struct P_ExprNode
{
  DBCC_Expr *expr;
  P_ExprNode *next;
};
static P_ExprNode *p_expr_node_new (DBCC_Expr *expr)
{
  P_ExprNode *rv = malloc (sizeof (P_ExprNode));
  rv->expr = expr;
  rv->next = NULL;
  return rv;
}
static void
p_expr_node_destroy (P_ExprNode *node)
{
  dbcc_expr_destroy (node->expr);
  free (node);
}
static void
p_expr_list_clear (P_ExprList *list)
{
  while (list->first != NULL)
    {
      P_ExprNode *kill = list->first;
      list->first= kill->next;
      p_expr_node_destroy (kill);
    }
  list->last = NULL;
}

typedef struct P_StatementList P_StatementList;
typedef struct P_StatementNode P_StatementNode;
struct P_StatementList
{
  P_StatementNode *first, *last;
};
struct P_StatementNode
{
  DBCC_Statement *statement;
  P_StatementNode *prev, *next;
};
static void
p_statement_node_destroy (P_StatementNode *node)
{
  dbcc_statement_destroy (node->statement);
  free (node);
}
static void
p_statement_list_clear (P_StatementList *list)
{
  while (list->first != NULL)
    {
      P_StatementNode *kill = list->first;
      list->first= kill->next;
      p_statement_node_destroy (kill);
    }
  list->last = NULL;
}

static void
p_statement_list_init_empty (P_StatementList *init)
{
  init->first = init->last = NULL;
}
static void
p_statement_list_init1 (P_StatementList *init, DBCC_Statement *stmt)
{
  P_StatementNode *node = malloc (sizeof (P_StatementNode));
  node->next = NULL;
  node->statement = stmt;
  init->first = init->last = node;
}
static void
p_statement_list_append (P_StatementList *list, DBCC_Statement *stmt)
{

  P_StatementNode *node = malloc (sizeof (P_StatementNode));
  node->next = NULL;
  node->statement = stmt;
  if (list->last == NULL)
    list->first = node;
  else
    list->last->next = node;
  list->last = node;
}
static void
p_statement_list_append_list (P_StatementList *list, P_StatementList *add)
{
  if (add->first == NULL)
    return;
  if (list->first == NULL)
    {
      *list = *add;
      return;
    }
  list->last->next = add->first;
  list->last = add->last;
}

static DBCC_Statement *
statement_from_list (P_StatementList *list)
{
  if (list->first == NULL)
    return dbcc_statement_new_empty();
  if (list->first->next == NULL)
    return list->first->statement;
  unsigned n_stmts = 0;
  for (P_StatementNode *at = list->first; at != NULL; at = at->next)
    n_stmts++;
  DBCC_Statement **stmts = malloc (sizeof(DBCC_Statement*) * n_stmts);
  unsigned i = 0;
  for (P_StatementNode *at = list->first; at != NULL; at = at->next, i++)
    stmts[i] = at->statement;
  while (list->first != NULL)
    {
      P_StatementNode *kill = list->first;
      list->first = kill->next;
      free (kill);
    }
  return dbcc_statement_new_compound(n_stmts, stmts, false);
}

#if 0
static P_AlignmentSpecifier *
p_alignment_specifier_new_by_type (DBCC_Type *type)
{
  P_AlignmentSpecifier *rv = malloc (sizeof (P_AlignmentSpecifier));
  rv->specifier_type = P_ALIGNMENT_SPECIFIER_BY_TYPE;
  rv->v_type = type;
  return rv;
}
static P_AlignmentSpecifier *
p_alignment_specifier_new_by_expr (DBCC_Expr *expr)
{
  P_AlignmentSpecifier *rv = malloc (sizeof (P_AlignmentSpecifier));
  rv->specifier_type = P_ALIGNMENT_SPECIFIER_BY_EXPR;
  rv->v_expr = expr;
  return rv;
}
#endif
  
static void
p_alignment_specifier_destroy (P_AlignmentSpecifier *spec)
{
  switch (spec->specifier_type)
    {
    case P_ALIGNMENT_SPECIFIER_BY_TYPE:
      dbcc_type_unref (spec->v_type);
      spec->v_type = NULL;
      break;
    case P_ALIGNMENT_SPECIFIER_BY_EXPR:
      dbcc_expr_destroy (spec->v_expr);
      spec->v_type = NULL;
      break;
    }
  free (spec);
}


// A designator is how by-name structure members or array elements are initialized.
// Note that there's a list of these b/c you can do things like:
//     Obj a = { .x.value[4] = 42 };
struct P_Designator
{
  bool is_array;
  union {
    DBCC_Expr *v_array_index;
    DBCC_Symbol *v_struct_member;
  };
  P_Designator *next;
};
static void 
p_designator_destroy (P_Designator *p)
{
  if (p->is_array)
    {
      if (p->v_array_index != NULL)
        dbcc_expr_destroy (p->v_array_index);
    }
  else
    {
      //object_member
    }
  free (p);
}
static P_Designator *
p_designator_new_array_index (DBCC_Expr *expr)
{
  P_Designator *rv = malloc (sizeof (P_Designator));
  rv->is_array = true;
  rv->v_array_index = expr;
  rv->next = NULL;
  return rv;
}
static P_Designator *
p_designator_new_struct_member (DBCC_Symbol *name)
{
  P_Designator *rv = malloc (sizeof (P_Designator));
  rv->is_array = false;
  rv->v_struct_member = name;
  rv->next = NULL;
  return rv;
}
  
static void
p_designator_list_clear (P_DesignatorList *list)
{
  while (list->first != NULL)
    {
      P_Designator *kill = list->first;
      list->first = kill->next;
      p_designator_destroy (kill);
    }
  list->last = NULL;
}


static void
structured_initializer_from_p_initializer_list (P_InitializerList *list,
                                                DBCC_StructuredInitializer *out);
static void
structured_initializer_piece_from_p_initializer (P_Initializer *zer,
                                                 DBCC_StructuredInitializerPiece *out)
{
  size_t n_designators = 0;
  for (P_Designator *at = zer->designators.first; at; at = at->next)
    n_designators++;
  DBCC_Designator *designators;
  if (n_designators == 0)
    designators = NULL;
  else
    designators = malloc (sizeof (DBCC_Designator) * n_designators);
  size_t di = 0;
  for (P_Designator *at = zer->designators.first; at != NULL; at = at->next, di++)
    {
      if (at->is_array)
        {
          designators[di].type = DBCC_DESIGNATOR_INDEX;
          designators[di].v_index = at->v_array_index;
        }
      else
        {
          designators[di].type = DBCC_DESIGNATOR_MEMBER;
          designators[di].v_member = at->v_struct_member;
        }
    }
  out->n_designators = n_designators;
  out->designators = designators;
  switch (zer->initializer_type)
    {
    case P_INITIALIZER_TYPE_STRUCTURED:
      structured_initializer_from_p_initializer_list (&zer->v_structured, &out->v_structured_initializer);
      out->is_expr = false;
      break;
    case P_INITIALIZER_TYPE_EXPR:
      out->v_expr = zer->v_expr;
      out->is_expr = true;
      break;
    }
}
static void
structured_initializer_from_p_initializer_list (P_InitializerList *list,
                                                DBCC_StructuredInitializer *out)
{
  size_t count = 0;
  for (P_Initializer *init = list->first; init != NULL; init = init->next)
    count++;
  out->n_pieces = count;
  out->pieces = malloc (count * sizeof (DBCC_StructuredInitializerPiece));
  size_t i = 0;
  for (P_Initializer *init = list->first; init != NULL; init = init->next)
    {
      structured_initializer_piece_from_p_initializer (init, out->pieces + i);
      i++;
    }
}
static DBCC_Type * type_from_parts (P_Context *context,
                                    P_Declaration *declaration,
                                    P_Declarator *declarator);

static P_Declarator *
declarator_find_parenthesized_part (P_Declarator *d)
{
  while (d != NULL)
    {
      switch (d->declarator_type)
      {
      case P_DECLARATOR_TYPE_NAME:
        return NULL;
      case P_DECLARATOR_TYPE_POINTER:
        d = d->v_pointer.target;
        break;
      case P_DECLARATOR_TYPE_ARRAY:
        d = d->v_array.child;
        break;
      case P_DECLARATOR_TYPE_VARLEN_ARRAY:
        d = d->v_varlen_array.child;
        break;
      case P_DECLARATOR_TYPE_BITFIELD:
        d = d->v_bitfield.child;
        break;
      case P_DECLARATOR_TYPE_FUNCTION:
        d = d->v_function.child;
        break;
      case P_DECLARATOR_TYPE_KR_FUNCTION:
        d = d->v_kr_function.child;
        break;
      case P_DECLARATOR_TYPE_PARENTHESIZED:
        return d;
      }
    }
  return NULL;
}
static DBCC_Symbol *
name_from_declarator (P_Declarator *d)
{
  while (d != NULL)
    {
      switch (d->declarator_type)
      {
      case P_DECLARATOR_TYPE_NAME:
        return d->v_name;
      case P_DECLARATOR_TYPE_POINTER:
        d = d->v_pointer.target;
        break;
      case P_DECLARATOR_TYPE_ARRAY:
        d = d->v_array.child;
        break;
      case P_DECLARATOR_TYPE_VARLEN_ARRAY:
        d = d->v_varlen_array.child;
        break;
      case P_DECLARATOR_TYPE_BITFIELD:
        d = d->v_bitfield.child;
        break;
      case P_DECLARATOR_TYPE_FUNCTION:
        d = d->v_function.child;
        break;
      case P_DECLARATOR_TYPE_KR_FUNCTION:
        d = d->v_kr_function.child;
        break;
      case P_DECLARATOR_TYPE_PARENTHESIZED:
        d = d->v_parenthesized.child;
        break;
      }
    }
  return NULL;
}

static DBCC_Type *
declarator_modify_type (P_Context *context, 
                        DBCC_Type *base_type,
                        P_Declarator *declarator,
                        bool          stop_at_parens)
{
  if (declarator == NULL)
    return base_type;
  switch (declarator->declarator_type)
    {
    case P_DECLARATOR_TYPE_NAME:
      return base_type;
    case P_DECLARATOR_TYPE_POINTER:
      return dbcc_type_new_pointer (context->target_env,
                                    base_type);
    case P_DECLARATOR_TYPE_ARRAY:
      {
        size_t count = 0;
        DBCC_Expr *size_expr = declarator->v_array.size;
        if (size_expr != NULL)
          {
            if (size_expr->base.constant == NULL
             || size_expr->base.constant->constant_type != DBCC_CONSTANT_TYPE_VALUE)
              {
                context->error = dbcc_error_new (DBCC_ERROR_CONSTANT_REQUIRED,
                                     "size of array must be indicated by a numeric constant expression");
                dbcc_error_add_code_position (context->error, size_expr->base.code_position);
                return NULL;
              }
            if (!dbcc_cast_value (dbcc_namespace_get_size_type(context->globals), &count,
                                  size_expr->base.value_type,
                                  size_expr->base.constant->v_value.data))
              {
                context->error = dbcc_error_new (DBCC_ERROR_EXPECTED_INT,
                                                 "bad expression type %s in array-size specifier",
                                                 dbcc_symbol_get_string (size_expr->base.value_type->base.name));
                return NULL;
              }
            return dbcc_type_new_array (context->target_env,
                                        count,
                                        base_type);
          }
      }
    case P_DECLARATOR_TYPE_VARLEN_ARRAY:
      return dbcc_type_new_varlen_array (context->target_env,
                                         base_type);
    case P_DECLARATOR_TYPE_BITFIELD:
      {
        DBCC_Expr *bw = declarator->v_bitfield.bit_width;
        size_t width;
        if (bw->base.constant == NULL
         || bw->base.constant->constant_type != DBCC_CONSTANT_TYPE_VALUE)
          {
            context->error = dbcc_error_new (DBCC_ERROR_CONSTANT_REQUIRED,
                                             "bitfield width must be an integer constant");
            dbcc_error_add_code_position(context->error, bw->base.code_position);
            return NULL;
          }
        if (!dbcc_cast_value (dbcc_namespace_get_size_type(context->globals), &width,
                              bw->base.value_type, bw->base.constant->v_value.data))
          {
            context->error = dbcc_error_new (DBCC_ERROR_EXPECTED_INT,
                                "bitfield width is not an integral type");
            dbcc_error_add_code_position(context->error, bw->base.code_position);
            return NULL;
          }

        // TODO: verify bitfield width is equal or smaller size of base_type
        // (INCLUDE C11 SECTION REFERENCE)

        //return dbcc_type_new_bitfield (width, base_type);
        return base_type;
      }
    case P_DECLARATOR_TYPE_PARENTHESIZED:
      {
        if (stop_at_parens)
          return base_type;
        else
          return declarator_modify_type (context, base_type, declarator->v_parenthesized.child, false);
      }
    case P_DECLARATOR_TYPE_FUNCTION:
      {
        P_Declarator *child = declarator->v_function.child;
        DBCC_Type *rettype = declarator_modify_type (context, base_type, child, true);
        if (rettype == NULL)
          return NULL;

        P_ParameterList plist = declarator->v_function.parameters;
        DBCC_Param *params;
        size_t n_params;
        if (!declaration_list_to_params (context, &plist.parameters, &n_params, &params))
          return NULL;

        DBCC_Type *fct = dbcc_type_new_function (rettype, n_params, params, plist.has_varargs);
        P_Declarator *subdecl = declarator_find_parenthesized_part (child);
        return declarator_modify_type (context, fct, subdecl, false);
      }
    case P_DECLARATOR_TYPE_KR_FUNCTION:
      {
        assert(0);              // TODO
        return NULL;
      }
    }
}

static DBCC_Type *
type_specifiers_to_type (P_Context *context,
                         P_TypeSpecifiers *specs)
{
  if (specs->counts[P_TYPE_SPECIFIERS_INDEX_COMPLEX])
    {
      if (specs->counts[P_TYPE_SPECIFIERS_INDEX_FLOAT])
        return dbcc_namespace_get_complex_float_type (context->globals);
      if (specs->counts[P_TYPE_SPECIFIERS_INDEX_DOUBLE])
        {
          if (specs->counts[P_TYPE_SPECIFIERS_INDEX_LONG])
            return dbcc_namespace_get_complex_long_double_type (context->globals);
          else
            return dbcc_namespace_get_complex_double_type (context->globals);
        }
      context->error = dbcc_error_new (DBCC_ERROR_NO_COMPLEX_VARIANT,
                                       "complex type of given base-type not allowed");
      return NULL;
    }
  else if (specs->counts[P_TYPE_SPECIFIERS_INDEX_IMAGINARY])
    {
      if (specs->counts[P_TYPE_SPECIFIERS_INDEX_FLOAT])
        return dbcc_namespace_get_imaginary_float_type (context->globals);
      if (specs->counts[P_TYPE_SPECIFIERS_INDEX_DOUBLE])
        {
          if (specs->counts[P_TYPE_SPECIFIERS_INDEX_LONG])
            return dbcc_namespace_get_imaginary_long_double_type (context->globals);
          else
            return dbcc_namespace_get_imaginary_double_type (context->globals);
        }
      context->error = dbcc_error_new (DBCC_ERROR_NO_COMPLEX_VARIANT,
                                       "imaginary type of given base-type not allowed");
      return NULL;
    }
  if (specs->counts[P_TYPE_SPECIFIERS_INDEX_UNSIGNED])
    {
      if (specs->counts[P_TYPE_SPECIFIERS_INDEX_CHAR])
        return dbcc_namespace_get_unsigned_short_type(context->globals);
      if (specs->counts[P_TYPE_SPECIFIERS_INDEX_SHORT])
        return dbcc_namespace_get_unsigned_short_type(context->globals);
      if (specs->counts[P_TYPE_SPECIFIERS_INDEX_LONG] == 2)
        return dbcc_namespace_get_unsigned_long_long_type(context->globals);
      if (specs->counts[P_TYPE_SPECIFIERS_INDEX_LONG] == 1)
        return dbcc_namespace_get_unsigned_long_type(context->globals);
      return dbcc_namespace_get_unsigned_int_type(context->globals);
    }
  else
    {
      if (specs->counts[P_TYPE_SPECIFIERS_INDEX_CHAR])
        {
          if (specs->counts[P_TYPE_SPECIFIERS_INDEX_SIGNED])
            return dbcc_namespace_get_signed_char_type(context->globals);
          else
            return dbcc_namespace_get_char_type(context->globals);
        }
      if (specs->counts[P_TYPE_SPECIFIERS_INDEX_SHORT])
        return dbcc_namespace_get_short_type(context->globals);
      if (specs->counts[P_TYPE_SPECIFIERS_INDEX_LONG] == 2)
        return dbcc_namespace_get_long_long_type(context->globals);
      if (specs->counts[P_TYPE_SPECIFIERS_INDEX_LONG] == 1)
        return dbcc_namespace_get_long_type(context->globals);
      if (specs->counts[P_TYPE_SPECIFIERS_INDEX_INT])
        return dbcc_namespace_get_int_type(context->globals);
    }
  if (specs->counts[P_TYPE_SPECIFIERS_INDEX_FLOAT])
    {
      return dbcc_namespace_get_float_type (context->globals);
    }
  if (specs->counts[P_TYPE_SPECIFIERS_INDEX_DOUBLE])
    {
      if (specs->counts[P_TYPE_SPECIFIERS_INDEX_LONG])
        return dbcc_namespace_get_long_double_type (context->globals);
      else
        return dbcc_namespace_get_double_type (context->globals);
    }
  if (specs->counts[P_TYPE_SPECIFIERS_INDEX_TYPEDEF]
   || specs->counts[P_TYPE_SPECIFIERS_INDEX_ENUM]
   || specs->counts[P_TYPE_SPECIFIERS_INDEX_STRUCT]
   || specs->counts[P_TYPE_SPECIFIERS_INDEX_UNION]
   || specs->counts[P_TYPE_SPECIFIERS_INDEX_ATOMIC])
    return specs->type;

  assert(0);
  return NULL;
}

static DBCC_Type *
type_from_parts (P_Context *context,
                 P_Declaration *declaration,
                 P_Declarator *declarator)
{
  DBCC_Type *type = type_specifiers_to_type(context, &declaration->v_declaration.specifiers);
  if (type == NULL)
    return NULL;
  DBCC_TypeQualifier q = declaration->v_declaration.qualifiers;
  if (q != 0)
    {
      type = dbcc_type_new_qualified (context->target_env, type, q, &context->error);
      if (type == NULL)
        return NULL;
    }

  // storage-class-specifiers and function-specifiers do not make new types

  return declarator_modify_type (context, type, declarator, false);
}

static bool
declaration_to_statement_list (P_Context *context, P_Declaration *a, P_StatementList *rv)
{
  p_statement_list_init_empty (rv);
  for (P_Declarator *declarator = a->v_declaration.declarators.first_declarator;
       declarator != NULL;
       declarator = declarator->next)
    {
      DBCC_Symbol *name = name_from_declarator (declarator);
      assert(name != NULL);
      DBCC_Type *type = type_from_parts (context, a, declarator);
      if (type == NULL)
        return false;
      DBCC_Statement *stmt = dbcc_statement_new_declaration (a->v_declaration.storage_class_specifiers,
                                                            type, name,
                                                            declarator->code_position,
                                                            &context->error);
      if (stmt == NULL)
        return false;
      p_statement_list_append (rv, stmt);
    }
  return true;
}
#define ITERATE_DECLARATORS_OF_DECLARATION_LIST(list)               \
    for (P_Declaration *declaration = (list)->first_declaration;      \
         declaration != NULL;                                       \
         declaration = declaration->next)                           \
      for (P_Declarator *declarator = declaration->v_declaration.declarators.first_declarator;   \
           declarator != NULL;                                     \
           declarator = declarator->next)

static size_t
declaration_list_count_declarators (P_DeclarationList *list)
{
  size_t rv = 0;
  ITERATE_DECLARATORS_OF_DECLARATION_LIST(list)
    rv++;
  return rv;
}



static bool
declaration_list_to_params (P_Context *context, 
                            P_DeclarationList *list,
                            size_t *n_params_out,
                            DBCC_Param **params_out)
{
  if (list == NULL)
    {
      *n_params_out = 0;
      *params_out = NULL;
      return true;
    }
  size_t n_params = declaration_list_count_declarators (list);
  DBCC_Param *params = malloc (sizeof (DBCC_Param) * n_params);
  size_t cur_n_params = 0;
  ITERATE_DECLARATORS_OF_DECLARATION_LIST(list)
    {
      DBCC_Type *param_type = type_from_parts (context, declaration, declarator);
      if (param_type == NULL)
        {
          free (params);        ///TODO other cleanup
          return false;
        }
      params[cur_n_params].name = name_from_declarator (declarator);
    }
  assert (cur_n_params == n_params);
  *n_params_out = n_params;
  *params_out = params;
  return true;
}

static void
error_set_code_location_from_expr (P_Context *context, DBCC_Expr *expr)
{
  if (expr->base.code_position != NULL)
    dbcc_error_add_code_position (context->error, expr->base.code_position);
}

#define MK_BINARY(rv, SHORTNAME, a, b)                                        \
  do{                                                                         \
    rv = dbcc_expr_new_binary_operator(CONTEXT_NS,                            \
                                       DBCC_BINARY_OPERATOR_##SHORTNAME,      \
                                       a, b, &context->error);                \
    if (rv == NULL)                                                           \
      FAIL();                                                                 \
  }while(0)

#define MK_INPLACE_UNARY(rv, SHORTNAME, in)                                   \
  do{                                                                         \
    rv = dbcc_expr_new_inplace_unary(CONTEXT_NS,                              \
                                     DBCC_INPLACE_UNARY_OPERATOR_##SHORTNAME, \
                                     in, &context->error);                    \
    if (rv == NULL)                                                           \
      FAIL();                                                                 \
  }while(0)
} ////// end of "included" code

%extra_argument {P_Context *context}

/* Conversion to Lemon was done Mar 2018 by Dave Benson */
%start_symbol translation_unit
%type generic_association           {P_GenericAssociation *}
%type optional_comma                {int}
%type enumeration_constant          {DBCC_Symbol *}
%type declaration                   {P_Declaration *}
%type external_declaration          {P_Declaration *}
%type parameter_declaration         {P_Declaration *}
%type static_assert_declaration     {P_Declaration *}
%type struct_declaration            {P_Declaration *}

%type declarator                    {P_Declarator *}
%type direct_abstract_declarator    {P_Declarator *}
%type abstract_declarator           {P_Declarator *}
%type direct_declarator             {P_Declarator *}
%type init_declarator               {P_Declarator *}
%type struct_declarator             {P_Declarator *}
%type function_definition           {P_Declaration *}

%type opt_designation               {P_DesignatorList}
%type designation                   {P_DesignatorList}
%type designator                    {P_Designator *}
%type enumerator                    {DBCC_EnumValue *}

%type pointer                       {P_Pointer}

%type expression                    {DBCC_Expr *}
%type additive_expression           {DBCC_Expr *}
%type and_expression                {DBCC_Expr *}
%type assignment_expression         {DBCC_Expr *}
%type cast_expression               {DBCC_Expr *}
%type conditional_expression        {DBCC_Expr *}
%type constant_expression           {DBCC_Expr *}
%type equality_expression           {DBCC_Expr *}
%type exclusive_or_expression       {DBCC_Expr *}
%type inclusive_or_expression       {DBCC_Expr *}
%type logical_and_expression        {DBCC_Expr *}
%type logical_or_expression         {DBCC_Expr *}
%type multiplicative_expression     {DBCC_Expr *}
%type postfix_expression            {DBCC_Expr *}
%type primary_expression            {DBCC_Expr *}
%type relational_expression         {DBCC_Expr *}
%type shift_expression              {DBCC_Expr *}
%type unary_expression              {DBCC_Expr *}
%type generic_selection             {DBCC_Expr *}

/* unlike the above DBCC_Expr* nonterminals, this may be  NULL */
%type opt_expression                {DBCC_Expr *}

%type initializer                   {P_Initializer *}
%type argument_expression_list      {P_ExprList}
%type block_item_list               {P_StatementList}
%type declaration_list              {P_DeclarationList}
%type designator_list               {P_DesignatorList}
%type enumerator_list               {P_EnumValueList}
%type generic_assoc_list            {P_GenericAssociationList}
%type init_declarator_list          {P_DeclaratorList}
%type initializer_list              {P_InitializerList}
%type opt_declaration_list          {P_DeclarationList}
%type parameter_list                {P_DeclarationList}

/* same a P_DeclarationList, except support for varargs */
%type parameter_type_list           {P_ParameterList} 
%type opt_parameter_type_list       {P_ParameterList} 

%type specifier_qualifier_list      {P_Declaration *}
%type struct_declaration_list       {P_DeclarationList}
%type struct_declarator_list        {P_DeclaratorList}
%type type_name                     {DBCC_Type *}
%type assignment_operator           {DBCC_InplaceBinaryOperator}
%type unary_operator                {DBCC_UnaryOperator}
%type identifier_list               {P_IdentifierList}
%type opt_identifier                {DBCC_Symbol *}

%type opt_type_qualifier_list       {DBCC_TypeQualifier}
%type type_qualifier_list           {DBCC_TypeQualifier}
%type type_qualifier                {DBCC_TypeQualifier}
%type alignment_specifier           {P_AlignmentSpecifier *}
%type enum_specifier                {DBCC_Type *}
%type function_specifier            {DBCC_FunctionSpecifiers}
%type storage_class_specifier       {DBCC_StorageClassSpecifier}
%type type_specifier                {P_TypeSpecifiers}
%type struct_or_union_specifier     {DBCC_Type *}
%type declaration_specifiers        {P_Declaration *}
%type opt_declaration_specifiers    {P_Declaration *}
%type statement                     {P_StatementList}
%type block_item                    {P_StatementList}
%type compound_statement            {P_StatementList}
%type expression_statement          {P_StatementList}
%type iteration_statement           {P_StatementList}
%type jump_statement                {P_StatementList}
%type labeled_statement             {P_StatementList}
%type selection_statement           {P_StatementList}
%type opt_static                    {bool}
%type string                        {DBCC_String}
%type external_declaration_list     {P_DeclarationList}
%type translation_unit              {P_DeclarationList}

%token_type {P_Token}
%token_prefix {P_TOKEN_}

%destructor generic_association           {p_generic_association_destroy($$);}
%destructor declaration                   {p_declaration_destroy($$);}
%destructor external_declaration          {p_declaration_destroy($$);}
%destructor parameter_declaration         {p_declaration_destroy($$);}
%destructor static_assert_declaration     {p_declaration_destroy($$);}
%destructor struct_declaration            {p_declaration_destroy($$);}

%destructor declarator                    {p_declarator_destroy($$);}
%destructor direct_abstract_declarator    {p_declarator_destroy($$);}
%destructor abstract_declarator           {p_declarator_destroy($$);}
%destructor direct_declarator             {p_declarator_destroy($$);}
%destructor init_declarator               {p_declarator_destroy($$);}
%destructor struct_declarator             {p_declarator_destroy($$);}
%destructor function_definition           {p_declaration_destroy($$);}

%destructor opt_designation               {p_designator_list_clear(&$$);}
%destructor designation                   {p_designator_list_clear(&$$);}
%destructor designator                    {p_designator_destroy($$);}
%destructor enumerator                    {free($$);}

%destructor expression                    {dbcc_expr_destroy($$);}
%destructor additive_expression           {dbcc_expr_destroy($$);}
%destructor and_expression                {dbcc_expr_destroy($$);}
%destructor assignment_expression         {dbcc_expr_destroy($$);}
%destructor cast_expression               {dbcc_expr_destroy($$);}
%destructor conditional_expression        {dbcc_expr_destroy($$);}
%destructor constant_expression           {dbcc_expr_destroy($$);}
%destructor equality_expression           {dbcc_expr_destroy($$);}
%destructor exclusive_or_expression       {dbcc_expr_destroy($$);}
%destructor inclusive_or_expression       {dbcc_expr_destroy($$);}
%destructor logical_and_expression        {dbcc_expr_destroy($$);}
%destructor logical_or_expression         {dbcc_expr_destroy($$);}
%destructor multiplicative_expression     {dbcc_expr_destroy($$);}
%destructor postfix_expression            {dbcc_expr_destroy($$);}
%destructor primary_expression            {dbcc_expr_destroy($$);}
%destructor relational_expression         {dbcc_expr_destroy($$);}
%destructor shift_expression              {dbcc_expr_destroy($$);}
%destructor unary_expression              {dbcc_expr_destroy($$);}
%destructor generic_selection             {dbcc_expr_destroy($$);}

// unlike the above DBCC_Expr* nonterminals, this may be  NULL */
%destructor opt_expression                {if ($$) dbcc_expr_destroy($$);}

%destructor initializer                   {p_initializer_destroy($$);}
%destructor argument_expression_list      {p_expr_list_clear(&$$);}
%destructor block_item_list               {p_statement_list_clear(&$$);}
%destructor declaration_list              {p_declaration_list_clear(&$$);}
%destructor designator_list               {p_designator_list_clear(&$$);}
%destructor enumerator_list               {p_enumerator_list_clear(&$$);}
%destructor generic_assoc_list            {p_generic_association_list_clear(&$$);}
%destructor init_declarator_list          {p_declarator_list_clear(&$$);}
%destructor initializer_list              {p_initializer_list_clear(&$$);}
%destructor opt_declaration_list          {p_declaration_list_clear(&$$);}
%destructor parameter_list                {p_declaration_list_clear(&$$);}

// a P_DeclarationList, except support for varargs */
%destructor parameter_type_list           {p_parameter_list_clear(&$$);}

%destructor specifier_qualifier_list      {p_declaration_destroy($$);}
%destructor struct_declaration_list       {p_declaration_list_clear(&$$);}
%destructor struct_declarator_list        {p_declarator_list_clear(&$$);}
%destructor type_name                     {dbcc_type_unref($$);}
%destructor identifier_list               {p_identifier_list_clear(&$$);}
%destructor opt_identifier                {}//TODO: symbol_unref

%destructor alignment_specifier           {p_alignment_specifier_destroy($$);}
%destructor enum_specifier                {dbcc_type_unref($$);}
%destructor type_specifier                {p_type_specifiers_clear(&$$);}
%destructor struct_or_union_specifier     {dbcc_type_unref($$);}
%destructor declaration_specifiers        {p_declaration_destroy($$);}
%destructor opt_declaration_specifiers    {p_declaration_destroy($$);}
%destructor statement                     {p_statement_list_clear(&$$);}
%destructor block_item                    {p_statement_list_clear(&$$);}
%destructor compound_statement            {p_statement_list_clear(&$$);}
%destructor expression_statement          {p_statement_list_clear(&$$);}
%destructor iteration_statement           {p_statement_list_clear(&$$);}
%destructor jump_statement                {p_statement_list_clear(&$$);}
%destructor labeled_statement             {p_statement_list_clear(&$$);}
%destructor selection_statement           {p_statement_list_clear(&$$);}
%destructor string                        {dbcc_string_clear(&$$);}
%destructor external_declaration_list     {p_declaration_list_clear(&$$);}
%destructor translation_unit              {(void)context;
                                           p_declaration_list_clear(&$$);}


primary_expression(rv) ::= IDENTIFIER(id).
        { DBCC_NamespaceEntry ns_entry;
          if (!p_context_lookup (context, id.v_identifier, id.code_position, &ns_entry))
            FAIL();             /// error set by p_context_lookup

          // for purposes for the grammar,
          //     DBCC_NAMESPACE_ENTRY_ENUM_VALUE
          // and 
          //     DBCC_NAMESPACE_ENTRY_TYPEDEF
          // should already have been handled at lexing time.
          assert(ns_entry.entry_type == DBCC_NAMESPACE_ENTRY_GLOBAL);

          rv = dbcc_expr_new_identifier (NULL, id.v_identifier, &context->error);


        }
primary_expression(rv) ::= I_CONSTANT(c).
        { DBCC_Type *t = dbcc_namespace_get_integer_type (context->globals,
                                                          c.v_i_constant.is_signed,
                                                          c.v_i_constant.sizeof_value);
          rv = dbcc_expr_new_int_constant (t, c.v_i_constant.v_uint64);
          dbcc_expr_add_code_position (rv, c.code_position); }
primary_expression(rv) ::= F_CONSTANT(c).
        { rv = dbcc_expr_new_float_constant (context->globals, 
                                             c.v_f_constant.float_type,
                                             c.v_f_constant.v_long_double);
          dbcc_expr_add_code_position (rv, c.code_position); }
primary_expression(rv) ::= ENUMERATION_CONSTANT(c).
        { rv = dbcc_expr_new_enum_constant (c.v_enum_value); }
primary_expression(rv) ::= CHAR_CONSTANT(c).
        { 
          DBCC_Type *t = dbcc_namespace_get_constant_char_type (c.v_char_constant.prefix);
          rv = dbcc_expr_new_char_constant (t, c.v_char_constant.code);
          dbcc_expr_add_code_position (rv, c.code_position); }
primary_expression(rv) ::= string(s).
        { rv = dbcc_expr_new_string_constant (context->globals, &s);
          s.str = NULL; }
primary_expression(rv) ::= LPAREN expression(e) RPAREN.
        { rv = e; e = NULL; }
primary_expression(rv) ::= generic_selection(g).
        { rv = g; g = NULL; }

// enumeration_constant is an identifier that is suitable for making into a EnumValue
enumeration_constant(rv) ::= IDENTIFIER(s).
	{ 
          assert(s.v_identifier != NULL);
          rv = s.v_identifier;
        }

string(rv) ::= STRING_LITERAL(s).
        { rv = s.v_string_literal; }

string(rv) ::= FUNC_NAME(s).
        { rv.str = strdup (dbcc_symbol_get_string (s.v_func_name));
          rv.length = s.v_func_name->length;
        }

generic_selection(rv) ::= GENERIC LPAREN assignment_expression(key_expr) COMMA generic_assoc_list(list) RPAREN.
        { DBCC_Expr *def_expr = NULL;
          unsigned count = 0;
          for (P_GenericAssociation *ass = list.first; ass != NULL; ass = ass->next)
            if (ass->type == NULL)
              def_expr = ass->expr;
            else
              count++;
          unsigned i = 0;
          DBCC_GenericAssociation *assocs = malloc (sizeof (DBCC_GenericAssociation) * count);

          for (P_GenericAssociation *ass = list.first; ass != NULL; ass = ass->next)
            if (ass->type != NULL)
              {
                assocs[i].type = ass->type;
                assocs[i].expr = ass->expr;
                i++;
              }
          while (list.first != NULL)
            {
              P_GenericAssociation *a = list.first;
              list.first = a->next;
              free (a);
            }
          list.last = NULL;
          rv = dbcc_expr_new_generic_selection (CONTEXT_NS,
                                                key_expr, count, assocs, def_expr,
                                                &context->error);
          if (rv == NULL)
            FAIL();
        }

generic_assoc_list(list) ::= generic_association(assoc).
        { list.first = list.last = assoc; assoc->next = NULL; assoc = NULL; }
generic_assoc_list(list) ::= generic_assoc_list(in) COMMA generic_association(assoc).
        { list = in;
          list.last->next = assoc;
          assoc->next = NULL;
          list.last = assoc; }

generic_association(assoc) ::= type_name(name) COLON assignment_expression(expr).
        { assoc = p_generic_association_new (name, expr); }
generic_association(assoc) ::= DEFAULT COLON assignment_expression(expr).
        { assoc = p_generic_association_new (NULL, expr); }

postfix_expression(rv) ::= primary_expression(a).
        { rv = a; a = NULL; }
postfix_expression(rv) ::= postfix_expression(a) LBRACKET expression(expr) RBRACKET.
        { rv = dbcc_expr_new_subscript (CONTEXT_NS, a, expr, &context->error);
        }
postfix_expression(rv) ::= postfix_expression(head) LPAREN RPAREN.
        { rv = dbcc_expr_new_call (CONTEXT_NS,
                                   head, 0, NULL,
                                   &context->error);
          if (rv == NULL)
            FAIL();
        }

postfix_expression(rv) ::= postfix_expression(head) LPAREN argument_expression_list(list) RPAREN.
        { size_t count = 0;
          for (P_ExprNode *at = list.first; at != NULL; at = at->next)
            count++;
          DBCC_Expr **args = malloc (sizeof (DBCC_Expr *) * count);
          unsigned i = 0;
          while (list.first != NULL)
            {
              P_ExprNode *kill = list.first;
              args[i++] = kill->expr;
              list.first = kill->next;
              free(kill);
            }
          rv = dbcc_expr_new_call (CONTEXT_NS,
                                   head, count, args,
                                   &context->error);
          if (rv == NULL)
            FAIL();
        }

postfix_expression(rv) ::= postfix_expression(head) PERIOD IDENTIFIER(id).
        { rv = dbcc_expr_new_access(CONTEXT_NS,
                                    false,              // head is not a expected to a pointer
                                    head, id.v_identifier,
                                    &context->error);
          if (rv == NULL)
            FAIL();
        }

postfix_expression(rv) ::= postfix_expression(head) POINTER_ACCESS IDENTIFIER(id).
        { rv = dbcc_expr_new_access(CONTEXT_NS,
                                    true,               // head is expected to a pointer
                                    head, id.v_identifier,
                                    &context->error);
          if (rv == NULL)
            FAIL();
        }
postfix_expression(rv) ::= postfix_expression(expr) INCREMENT.
        { MK_INPLACE_UNARY(rv, POST_INCR, expr); }
postfix_expression(rv) ::= postfix_expression(expr) DECREMENT.
        { MK_INPLACE_UNARY(rv, POST_DECR, expr); }
postfix_expression(rv) ::= LPAREN type_name(type) RPAREN LBRACE initializer_list(list) optional_comma RBRACE.
        { DBCC_StructuredInitializer sinit;
          structured_initializer_from_p_initializer_list (&list, &sinit);
          rv = dbcc_expr_new_structured_initializer(&sinit);  }

optional_comma ::= COMMA.
optional_comma ::= .

argument_expression_list(list) ::= assignment_expression(expr).
        { P_ExprNode *n = p_expr_node_new (expr);
          list.first = list.last = n; }
argument_expression_list(list) ::= argument_expression_list(in) COMMA assignment_expression(expr).
        { list = in;
          P_ExprNode *n = p_expr_node_new (expr);
          list.last->next = n;
          list.last = n; }

unary_expression(out) ::= postfix_expression(in).
        { out = in; in = NULL; }

unary_expression(rv) ::= INC_OP unary_expression(expr).
        { MK_INPLACE_UNARY (rv, PRE_INCR, expr); }
unary_expression(rv) ::= DEC_OP unary_expression(expr).
        { MK_INPLACE_UNARY (rv, PRE_DECR, expr); }
unary_expression(rv) ::= unary_operator(op) cast_expression(expr).
        { rv = dbcc_expr_new_unary(CONTEXT_NS, op, expr, &context->error);
          if (rv == NULL)
            FAIL();
        }
unary_expression(rv) ::= SIZEOF unary_expression(expr).
        { rv = dbcc_expr_new_sizeof_expr(CONTEXT_NS, expr, &context->error); 
          if (rv == NULL)
            FAIL();
        }
unary_expression(rv) ::= SIZEOF(sizeof_token) LPAREN type_name(type) RPAREN.
        { rv = dbcc_expr_new_sizeof_type(CONTEXT_NS,
                                         sizeof_token.code_position,
                                         type,
                                         &context->error);
          if (rv == NULL) FAIL();
        }
unary_expression(rv) ::= ALIGNOF LPAREN type_name(type) RPAREN.
        { rv = dbcc_expr_new_alignof_type(context->globals, type, &context->error);
          if (rv == NULL) FAIL();
        }

unary_operator(rv) ::= AMPERSAND.
        { rv = DBCC_UNARY_OPERATOR_REFERENCE; }
unary_operator(rv) ::= ASTERISK.
        { rv = DBCC_UNARY_OPERATOR_DEREFERENCE; }
unary_operator(rv) ::= PLUS.
        { rv = DBCC_UNARY_OPERATOR_NOOP; }
unary_operator(rv) ::= MINUS.
        { rv = DBCC_UNARY_OPERATOR_NEGATE; }
unary_operator(rv) ::= TILDE.
        { rv = DBCC_UNARY_OPERATOR_BITWISE_NOT; }
unary_operator(rv) ::= EXCLAMATION_POINT.
        { rv = DBCC_UNARY_OPERATOR_LOGICAL_NOT; }

cast_expression(rv) ::= unary_expression(expr).
        { rv = expr; expr = NULL; }
cast_expression(rv) ::= LPAREN type_name(type) RPAREN cast_expression(expr).
        { rv = dbcc_expr_new_cast (CONTEXT_NS, type, expr, &context->error);
          if (rv == NULL)
            FAIL();
        }

multiplicative_expression(rv) ::= cast_expression(expr).
        { rv = expr; expr = NULL; }
multiplicative_expression(rv) ::= multiplicative_expression(a) ASTERISK cast_expression(b).
        { MK_BINARY (rv, MUL, a, b); }
multiplicative_expression(rv) ::= multiplicative_expression(a) SLASH cast_expression(b).
        { MK_BINARY (rv, DIV, a, b); }
multiplicative_expression(rv) ::= multiplicative_expression(a) PERCENT cast_expression(b).
        { MK_BINARY (rv, REM, a, b); }

additive_expression(rv) ::= multiplicative_expression(expr).
        { rv = expr; expr = NULL; }
additive_expression(rv) ::= additive_expression(a) PLUS multiplicative_expression(b).
        { rv = dbcc_expr_new_binary_operator (context->globals, DBCC_BINARY_OPERATOR_ADD, a, b, &context->error);
          if (rv == NULL)
            FAIL(); }
additive_expression(rv) ::= additive_expression(a) MINUS multiplicative_expression(b).
        { rv = dbcc_expr_new_binary_operator (context->globals, DBCC_BINARY_OPERATOR_SUB, a, b, &context->error);
          if (rv == NULL)
            FAIL(); }

shift_expression(rv) ::= additive_expression(expr).
        { rv = expr; expr = NULL; }
shift_expression(rv) ::= shift_expression(a) SHIFT_LEFT additive_expression(b).
        { rv = dbcc_expr_new_binary_operator (context->globals, DBCC_BINARY_OPERATOR_SHIFT_LEFT, a, b, &context->error);
          if (rv == NULL)
            FAIL(); }
shift_expression(rv) ::= shift_expression(a) SHIFT_RIGHT additive_expression(b).
        { rv = dbcc_expr_new_binary_operator (context->globals, DBCC_BINARY_OPERATOR_SHIFT_RIGHT, a, b, &context->error);
          if (rv == NULL)
            FAIL(); }

relational_expression(rv) ::= shift_expression(expr).
        { rv = expr; expr = NULL; }
relational_expression(rv) ::= relational_expression(a) LESS_THAN shift_expression(b).
        { rv = dbcc_expr_new_binary_operator (context->globals, DBCC_BINARY_OPERATOR_LT, a, b, &context->error);
          if (rv == NULL)
            FAIL(); }
relational_expression(rv) ::= relational_expression(a) GREATER_THAN shift_expression(b).
        { rv = dbcc_expr_new_binary_operator (context->globals, DBCC_BINARY_OPERATOR_GT, a, b, &context->error);
          if (rv == NULL)
            FAIL(); }
relational_expression(rv) ::= relational_expression(a) LE shift_expression(b).
        { rv = dbcc_expr_new_binary_operator (context->globals, DBCC_BINARY_OPERATOR_LTEQ, a, b, &context->error);
          a = b = NULL; }
relational_expression(rv) ::= relational_expression(a) GE shift_expression(b).
        { rv = dbcc_expr_new_binary_operator (context->globals, DBCC_BINARY_OPERATOR_GTEQ, a, b, &context->error);
          a = b = NULL; }

equality_expression(rv) ::= relational_expression(expr).
        { rv = expr; expr = NULL; }
// example: a == b
equality_expression(rv) ::= equality_expression(a) IS_EQUAL_TO relational_expression(b).
        { rv = dbcc_expr_new_binary_operator (context->globals, DBCC_BINARY_OPERATOR_EQ, a, b, &context->error);
          a = b = NULL; }
// example: a != b
equality_expression(rv) ::= equality_expression(a) NOT_EQUAL_TO relational_expression(b).
        { rv = dbcc_expr_new_binary_operator (context->globals, DBCC_BINARY_OPERATOR_NE, a, b, &context->error);
          a = b = NULL; }

and_expression(rv) ::= equality_expression(expr).
        { rv = expr; expr = NULL; }
and_expression(rv) ::= and_expression(a) AMPERSAND equality_expression(b).
        { rv = dbcc_expr_new_binary_operator (context->globals, DBCC_BINARY_OPERATOR_BITWISE_AND, a, b, &context->error);
          a = b = NULL; }

exclusive_or_expression(rv) ::= and_expression(expr).
        { rv = expr; expr = NULL; }
exclusive_or_expression(rv) ::= exclusive_or_expression(a) CARAT and_expression(b).
        { rv = dbcc_expr_new_binary_operator (context->globals, DBCC_BINARY_OPERATOR_BITWISE_XOR, a, b, &context->error);
          a = b = NULL; }

inclusive_or_expression(rv) ::= exclusive_or_expression(expr).
        { rv = expr; expr = NULL; }
inclusive_or_expression(rv) ::= inclusive_or_expression(a) VERTICAL_BAR exclusive_or_expression(b).
        { rv = dbcc_expr_new_binary_operator (context->globals, DBCC_BINARY_OPERATOR_BITWISE_OR, a, b, &context->error);
          a = b = NULL; }

logical_and_expression(rv) ::= inclusive_or_expression(expr).
        { rv = expr; expr = NULL; }
logical_and_expression(rv) ::= logical_and_expression(a) LOGICAL_AND inclusive_or_expression(b).
        { rv = dbcc_expr_new_binary_operator (context->globals, DBCC_BINARY_OPERATOR_LOGICAL_AND, a, b, &context->error);
          a = b = NULL; }

logical_or_expression(rv) ::= logical_and_expression(expr).
        { rv = expr; expr = NULL; }
logical_or_expression(rv) ::= logical_or_expression(a) LOGICAL_OR logical_and_expression(b).
        { rv = dbcc_expr_new_binary_operator (context->globals, DBCC_BINARY_OPERATOR_LOGICAL_OR, a, b, &context->error);
          a = b = NULL; }

conditional_expression(rv) ::= logical_or_expression(expr).
        { rv = expr; expr = NULL; }
conditional_expression(rv) ::= logical_or_expression(a) QUESTION_MARK expression(b) COLON conditional_expression(c).
        { rv = dbcc_expr_new_ternary (context->globals, a, b, c, &context->error);
          if (!rv)
            FAIL();
        }

assignment_expression(rv) ::= conditional_expression(expr).
        { rv = expr; expr = NULL; }
assignment_expression(rv) ::= unary_expression(a) assignment_operator(op) assignment_expression(b).
	{ rv = dbcc_expr_new_inplace_binary (context->globals, op, a, b, &context->error);
          if (!rv)
            FAIL();
        }

assignment_operator(rv) ::= EQUAL_SIGN.
        { rv = DBCC_INPLACE_BINARY_OPERATOR_ASSIGN; }
assignment_operator(rv) ::= MULTIPLY_ASSIGN.
        { rv = DBCC_INPLACE_BINARY_OPERATOR_MUL_ASSIGN; }
assignment_operator(rv) ::= DIVIDE_ASSIGN.
        { rv = DBCC_INPLACE_BINARY_OPERATOR_DIV_ASSIGN; }
assignment_operator(rv) ::= REMAINDER_ASSIGN.
        { rv = DBCC_INPLACE_BINARY_OPERATOR_REM_ASSIGN; }
assignment_operator(rv) ::= ADD_ASSIGN.
        { rv = DBCC_INPLACE_BINARY_OPERATOR_ADD_ASSIGN; }
assignment_operator(rv) ::= SUBTRACT_ASSIGN.
        { rv = DBCC_INPLACE_BINARY_OPERATOR_SUB_ASSIGN; }
assignment_operator(rv) ::= SHIFT_LEFT_ASSIGN.
        { rv = DBCC_INPLACE_BINARY_OPERATOR_LEFT_SHIFT_ASSIGN; }
assignment_operator(rv) ::= SHIFT_RIGHT_ASSIGN.
        { rv = DBCC_INPLACE_BINARY_OPERATOR_RIGHT_SHIFT_ASSIGN; }
assignment_operator(rv) ::= BITWISE_AND_ASSIGN.
        { rv = DBCC_INPLACE_BINARY_OPERATOR_AND_ASSIGN; }
assignment_operator(rv) ::= BITWISE_XOR_ASSIGN.
        { rv = DBCC_INPLACE_BINARY_OPERATOR_XOR_ASSIGN; }
assignment_operator(rv) ::= BITWISE_OR_ASSIGN.
        { rv = DBCC_INPLACE_BINARY_OPERATOR_OR_ASSIGN; }

expression(rv) ::= assignment_expression(expr).
        { rv = expr; expr = NULL; }
expression(rv) ::= expression(a) COMMA assignment_expression(b).
        { MK_BINARY(rv, COMMA, a, b); }

constant_expression(rv) ::= conditional_expression(a).
	{ rv = a;
#if 0
          if (rv->base.constant == NULL)
            {
              context->error = dbcc_error_new (DBCC_ERROR_CONSTANT_REQUIRED,
                                 "constant value required");
              error_set_code_location_from_expr (context, a);
              FAIL();
            }
#endif
        }

opt_expression(o) ::= expression(i).
        { o = i; i = NULL; }
opt_expression(o) ::= .
        { o = NULL; }

declaration(rv) ::= declaration_specifiers(specs) SEMICOLON.
        { rv = specs; 
          specs = NULL; }
declaration(rv) ::= declaration_specifiers(specs) init_declarator_list(names) SEMICOLON.
        { rv = specs;
          while (names.first_declarator != NULL)
            {
              P_Declarator *n = names.first_declarator;
              names.first_declarator = n->next;
              n->next = NULL;
              p_declaration_append_declarator (rv, n);
            }
        }
declaration(rv) ::= static_assert_declaration(sadecl).
        { rv = sadecl; }

opt_declaration_specifiers(rv) ::= declaration_specifiers(a).
        { rv = a; }
opt_declaration_specifiers(rv) ::= .
        { rv = p_declaration_new (); }

declaration_specifiers(rv) ::= storage_class_specifier(scs) opt_declaration_specifiers(a).
        { rv = a;
          rv->v_declaration.storage_class_specifiers |= scs; }
declaration_specifiers(rv) ::= type_specifier(ts) opt_declaration_specifiers(a).
        { rv = a; a = NULL;
          if (!p_type_specifiers_combine (context, &a->v_declaration.specifiers, &ts))
            FAIL();
        }
declaration_specifiers(rv) ::= type_qualifier(tq) opt_declaration_specifiers(a).
        { rv = a;
          rv->v_declaration.qualifiers |= tq; }
declaration_specifiers(rv) ::= alignment_specifier(s) opt_declaration_specifiers(a).
        { rv = a;
          if (rv->v_declaration.alignment_specifier != NULL)
            {
              context->error = dbcc_error_new (DBCC_ERROR_DUPLICATE,
                                               "multiple alignment specifies given: not allowed");
              FAIL();
            }
          rv->v_declaration.alignment_specifier = s; }
declaration_specifiers(rv) ::= function_specifier(fspec).
        { rv->v_declaration.function_specifiers |= fspec; }

init_declarator_list(list) ::= init_declarator(d).
        { list.first_declarator = list.last_declarator = d;
          d->next = NULL; }
init_declarator_list(list) ::= init_declarator_list(a) COMMA init_declarator(d).
        { list = a;
          d->next = NULL;               // unneeded
          list.last_declarator->next = d;
          list.last_declarator = d; }

init_declarator(rv) ::= declarator(decl) EQUALS initializer(init).
        { assert(decl->initializer == NULL);
          decl->initializer = init;
          rv = decl;
          decl = NULL;
          init = NULL; }
init_declarator(rv) ::= declarator(decl).
        { rv = decl;
          decl = NULL; }

storage_class_specifier(rv) ::= TYPEDEF.
        { rv = DBCC_STORAGE_CLASS_SPECIFIER_TYPEDEF; }
storage_class_specifier(rv) ::= EXTERN.
        { rv = DBCC_STORAGE_CLASS_SPECIFIER_EXTERN; }
storage_class_specifier(rv) ::= STATIC.
        { rv = DBCC_STORAGE_CLASS_SPECIFIER_STATIC; }
storage_class_specifier(rv) ::= THREAD_LOCAL.
        { rv = DBCC_STORAGE_CLASS_SPECIFIER_THREAD_LOCAL; }
storage_class_specifier(rv) ::= AUTO.
        { rv = DBCC_STORAGE_CLASS_SPECIFIER_AUTO; }
storage_class_specifier(rv) ::= REGISTER.
        { rv = DBCC_STORAGE_CLASS_SPECIFIER_REGISTER; }

type_specifier(rv) ::= VOID.
        { rv = P_TYPE_SPECIFIERS_INIT;
          rv.counts[P_TYPE_SPECIFIERS_INDEX_VOID] = 1; }
type_specifier(rv) ::= CHAR.
        { rv = P_TYPE_SPECIFIERS_INIT;
          rv.counts[P_TYPE_SPECIFIERS_INDEX_CHAR] = 1; }
type_specifier(rv) ::= INT.
        { rv = P_TYPE_SPECIFIERS_INIT;
          rv.counts[P_TYPE_SPECIFIERS_INDEX_CHAR] = 1; }
type_specifier(rv) ::= SHORT.
        { rv = P_TYPE_SPECIFIERS_INIT;
          rv.counts[P_TYPE_SPECIFIERS_INDEX_SHORT] = 1; }
type_specifier(rv) ::= LONG.
        { rv = P_TYPE_SPECIFIERS_INIT;
          rv.counts[P_TYPE_SPECIFIERS_INDEX_CHAR] = 1; }
type_specifier(rv) ::= FLOAT.
        { rv = P_TYPE_SPECIFIERS_INIT;
          rv.counts[P_TYPE_SPECIFIERS_INDEX_CHAR] = 1; }
type_specifier(rv) ::= DOUBLE.
        { rv = P_TYPE_SPECIFIERS_INIT;
          rv.counts[P_TYPE_SPECIFIERS_INDEX_CHAR] = 1; }
type_specifier(rv) ::= SIGNED.
        { rv = P_TYPE_SPECIFIERS_INIT;
          rv.counts[P_TYPE_SPECIFIERS_INDEX_CHAR] = 1; }
type_specifier(rv) ::= UNSIGNED.
        { rv = P_TYPE_SPECIFIERS_INIT;
          rv.counts[P_TYPE_SPECIFIERS_INDEX_CHAR] = 1; }
type_specifier(rv) ::= BOOL.
        { rv = P_TYPE_SPECIFIERS_INIT;
          rv.counts[P_TYPE_SPECIFIERS_INDEX_CHAR] = 1; }
type_specifier(rv) ::= COMPLEX.
        { rv = P_TYPE_SPECIFIERS_INIT;
          rv.counts[P_TYPE_SPECIFIERS_INDEX_CHAR] = 1; }
type_specifier(rv) ::= IMAGINARY.
        { rv = P_TYPE_SPECIFIERS_INIT;
          rv.counts[P_TYPE_SPECIFIERS_INDEX_CHAR] = 1; }
type_specifier(rv) ::= ATOMIC LPAREN type_name(nonatomic_type) RPAREN.
        { rv = P_TYPE_SPECIFIERS_INIT;
          rv.counts[P_TYPE_SPECIFIERS_INDEX_ATOMIC]++;
          rv.type = dbcc_type_new_qualified (context->target_env, nonatomic_type, DBCC_TYPE_QUALIFIER_ATOMIC, &context->error);
          if (rv.type == NULL)
            {
              FAIL();
            }
        }
type_specifier(rv) ::= struct_or_union_specifier(a).
        { rv = P_TYPE_SPECIFIERS_INIT;
          unsigned s_or_u_index = a->metatype == DBCC_TYPE_METATYPE_STRUCT
                                ? P_TYPE_SPECIFIERS_INDEX_STRUCT
                                : P_TYPE_SPECIFIERS_INDEX_UNION;
          rv.counts[s_or_u_index] = 1;
          rv.type = a; }
type_specifier(rv) ::= enum_specifier(a).
        { rv = P_TYPE_SPECIFIERS_INIT;
          rv.counts[P_TYPE_SPECIFIERS_INDEX_ENUM] = 1;
          rv.type = a; }
type_specifier(rv) ::= TYPEDEF_NAME(t).
	{ rv = P_TYPE_SPECIFIERS_INIT;
          rv.counts[P_TYPE_SPECIFIERS_INDEX_TYPEDEF] = 1;
          rv.type = t.v_typedef_name.type; }

struct_or_union_specifier(rv) ::= STRUCT IDENTIFIER(tag_token).
        { rv = context_new_struct_stub (context,
                                        tag_token.v_identifier,
                                        tag_token.code_position);
          if (rv == NULL) 
            FAIL();
        }
struct_or_union_specifier(rv)  ::= STRUCT(s) opt_identifier(tag) LBRACE struct_declaration_list(list) RBRACE.
        { size_t n_params;
          DBCC_Param *params;
          if (!declaration_list_to_params (context, &list, &n_params, &params))
            FAIL();
          rv = context_new_struct (context,
                                   tag,
                                   s.code_position,
                                   n_params, params);
          if (rv == NULL) 
            FAIL();
        }
struct_or_union_specifier(rv) ::= UNION IDENTIFIER(tag_token).
        { rv = context_new_union_stub (context,
                                       tag_token.v_identifier,
                                       tag_token.code_position);
          if (rv == NULL) 
            FAIL();
        }
struct_or_union_specifier(rv)  ::= UNION(s) opt_identifier(tag) LBRACE struct_declaration_list(list) RBRACE.
        { 
          size_t n_params;
          DBCC_Param *params;
          if (!declaration_list_to_params (context, &list, &n_params, &params))
            FAIL();
          rv = context_new_union  (context,
                                   tag,
                                   s.code_position,
                                   n_params, params);
          if (rv == NULL) 
            FAIL();
        }

struct_declaration_list(rv) ::= struct_declaration(a).
        { rv.first_declaration = rv.last_declaration = a;
          a->next = NULL; }
struct_declaration_list(rv) ::= struct_declaration_list(in) struct_declaration(a).
        { rv = in;
          rv.last_declaration->next = a;
          rv.last_declaration = a;
          a->next = NULL; }

struct_declaration(rv) ::= specifier_qualifier_list(in) SEMICOLON.   /* for anonymous struct/union within structs */
        {
          assert(in->v_declaration.specifiers.counts[P_TYPE_SPECIFIERS_INDEX_STRUCT] > 0
              || in->v_declaration.specifiers.counts[P_TYPE_SPECIFIERS_INDEX_UNION] > 0);
          rv = in;
        }
struct_declaration(rv) ::= specifier_qualifier_list(list) struct_declarator_list(add) SEMICOLON.
        {
          assert(list->v_declaration.declarators.first_declarator == NULL);
          list->v_declaration.declarators = add;
          rv = list;
        }
struct_declaration(rv) ::= static_assert_declaration(sadecl).
	{
          rv = sadecl;
          sadecl = NULL;
	}

specifier_qualifier_list(rv) ::= type_specifier(ts) specifier_qualifier_list(a).
        { rv = a; 
          if (!p_type_specifiers_combine (context, &rv->v_declaration.specifiers, &ts))
            FAIL();
        }

specifier_qualifier_list(rv) ::= type_specifier(ts).
	{ rv = p_declaration_new ();
          rv->v_declaration.specifiers = ts; }

specifier_qualifier_list(rv) ::= type_qualifier(tq) specifier_qualifier_list(a).
        { rv = a;
          rv->v_declaration.qualifiers |= tq; }
specifier_qualifier_list(rv) ::= type_qualifier(tq).
	{ rv = p_declaration_new ();
          rv->v_declaration.qualifiers |= tq; }

// a comma-separated list of variables with qualifiers,
// in an expression like 'int a, *b'
// the whole thing is a "declaration" and "a" and "b" are "declarators".
struct_declarator_list(list) ::= struct_declarator(decl).
        { list.first_declarator = list.last_declarator = decl;
          decl->next = NULL; }
struct_declarator_list(list) ::= struct_declarator_list(in) COMMA struct_declarator(decl).
        { list = in;
          list.last_declarator->next = decl;
          list.last_declarator = decl;
          decl->next = NULL; }

struct_declarator(sdecl) ::= COLON constant_expression(bitcount).
        { sdecl = p_declarator_new_bitfield (NULL, bitcount); }
struct_declarator(sdecl) ::= declarator(decl) COLON constant_expression(bitcount).
        { sdecl = p_declarator_new_bitfield (decl, bitcount); }
struct_declarator(sdecl) ::= declarator(decl).
        { sdecl = decl; }

enum_specifier(rv) ::= ENUM opt_identifier(id) LBRACE enumerator_list(list) opt_comma RBRACE.
        { unsigned n_values = 0;
          for (P_EnumValueNode *e = list.first; e != NULL; e = e->next)
            n_values++;
          unsigned i = 0;
          DBCC_EnumValue *evalues = DBCC_NEW_ARRAY(n_values, DBCC_EnumValue);
          for (P_EnumValueNode *e = list.first; e != NULL; e = e->next, i++)
            evalues[i] = *e->enum_value;
          DBCC_Error *error = NULL;
          rv = dbcc_type_new_enum (context->target_env, id, n_values, evalues, &error);
          p_enumerator_list_clear (&list);
        }

opt_identifier(rv) ::= .
        { rv = NULL; }
opt_identifier(rv) ::= IDENTIFIER(id).
        { rv = id.v_identifier; }

enumerator_list(rv) ::= enumerator(e).
        { P_EnumValueNode *node = malloc (sizeof (P_EnumValueNode));
          node->enum_value = e;
          node->next =  NULL;
          rv.first = rv.last = node; }
enumerator_list(rv) ::= enumerator_list(a) COMMA enumerator(e).
        { P_EnumValueNode *node = malloc (sizeof (P_EnumValueNode));
          node->enum_value = e;
          node->next =  NULL;
          if (a.first == NULL)
            a.first = node;
          else
            a.last->next = node;
          a.last = node;
          rv = a; }

/* 6.7.2.2.3: ... If the first enumerator has no =, the value of
                  its enumeration constant is 0. Each subsequent enumerator
                  with no = defines its enumeration constant as the value
                  of the constant expression obtained by adding 1 to the value
                  of the previous enumeration constant. ... */
// an enumeration value, with value either implicit (assigned automatically)
// or explicit (derived from a constant expression).
enumerator(rv) ::= enumeration_constant(c) EQUALS constant_expression(v).
        { 
          int value;
          /* 6.7.2.2.2.  The expression that defines the value of an enumeration constant
                         shall be an integer constant expression that has a value representable
                         as an int. */
          if (v->base.constant == NULL)
            {
              context->error = dbcc_error_new (DBCC_ERROR_CONSTANT_REQUIRED,
                                 "constant value required");
              error_set_code_location_from_expr (context, v);
              FAIL();
            }
          if (!dbcc_cast_value (dbcc_namespace_get_int_type (context->globals),
                                &value,
                                v->base.value_type,
                                v->base.constant->v_value.data))
            {
              DBCC_Symbol *type_name = v->base.value_type->base.name;
              context->error = dbcc_error_new (DBCC_ERROR_EXPECTED_INT,
                                               "enumeration value expression must be an int, got %s (for %s)",
                                               type_name ? dbcc_symbol_get_string(type_name) : "<anonymous-type>",
                                               dbcc_symbol_get_string(c));
              FAIL();
            }
          context->next_enum_value = value + 1;
          rv = dbcc_enum_value_new (c, value);
        }
enumerator(rv) ::= enumeration_constant(c).
        { 
          int value = context->next_enum_value;
          context->next_enum_value = value + 1;
          rv = dbcc_enum_value_new (c, value);
        }

type_qualifier(rv) ::= CONST.
        { rv = DBCC_TYPE_QUALIFIER_CONST; }
type_qualifier(rv) ::= RESTRICT.
        { rv = DBCC_TYPE_QUALIFIER_RESTRICT; }
type_qualifier(rv) ::= VOLATILE.
        { rv = DBCC_TYPE_QUALIFIER_VOLATILE; }
type_qualifier(rv) ::= ATOMIC.
        { rv = DBCC_TYPE_QUALIFIER_ATOMIC; }

function_specifier(rv) ::= INLINE.
        { rv = DBCC_FUNCTION_SPECIFIER_INLINE; }
function_specifier(rv) ::= NORETURN.
        { rv = DBCC_FUNCTION_SPECIFIER_NORETURN; }

alignment_specifier(rv) ::= ALIGNAS LPAREN type_name(type) RPAREN.
        { rv = malloc (sizeof (P_AlignmentSpecifier));
          rv->specifier_type = P_ALIGNMENT_SPECIFIER_BY_TYPE;
          rv->v_type = type; }
alignment_specifier(rv) ::= ALIGNAS LPAREN constant_expression(expr) RPAREN.
        { rv = malloc (sizeof (P_AlignmentSpecifier));
          rv->specifier_type = P_ALIGNMENT_SPECIFIER_BY_EXPR;
          rv->v_expr = expr; }

declarator(out) ::= pointer(ptr) direct_declarator(in).
        { P_Declarator *cur = in;
          for (unsigned i = 0; i < ptr.n_ptr; i++)
            cur = p_declarator_new_pointer(ptr.ptr_type_qualifiers[i], cur, ptr.code_position);
          out = cur; }
declarator(out) ::= direct_declarator(in).
        { out = in; }

direct_declarator(decl) ::= IDENTIFIER(id).
        { decl = p_declarator_new_name (id.v_identifier); }

direct_declarator(decl) ::= LPAREN declarator(in) RPAREN.
        { decl = in; }
direct_declarator(decl) ::= direct_declarator(in) LBRACKET opt_type_qualifier_list(tq) RBRACKET.
        { decl = p_declarator_new_array(tq, NULL, in); }

direct_declarator(decl) ::= direct_declarator(in) LBRACKET STATIC opt_type_qualifier_list(tq) assignment_expression(index_expr) RBRACKET.
        { decl = p_declarator_new_array(tq, index_expr, in); }
direct_declarator(decl) ::= direct_declarator(in) LBRACKET type_qualifier_list(tq) STATIC assignment_expression(index_expr) RBRACKET.
        { decl = p_declarator_new_array(tq, index_expr, in); }
direct_declarator(decl) ::= direct_declarator(in) LBRACKET opt_type_qualifier_list(tq) assignment_expression(index_expr) RBRACKET.
        { decl = p_declarator_new_array(tq, index_expr, in); }
direct_declarator(decl) ::= direct_declarator(in) LBRACKET opt_type_qualifier_list(tq) ASTERISK RBRACKET.
        { decl = p_declarator_new_varlen_array(tq, in); }
direct_declarator(decl) ::= direct_declarator(in) LPAREN parameter_type_list(plist) RPAREN.
        { decl = p_declarator_new_function(in, &plist); }
direct_declarator(decl) ::= direct_declarator(in) LPAREN RPAREN.
        { decl = p_declarator_new_function(in, NULL); }
direct_declarator(decl) ::= direct_declarator(in) LPAREN identifier_list(idlist) RPAREN.
        { decl = p_declarator_new_function_kr (in, &idlist); }

opt_comma ::= .
opt_comma ::= COMMA.

pointer(rv) ::= ASTERISK opt_type_qualifier_list(tq) pointer(a).
        { rv.n_ptr = a.n_ptr + 1;
          rv.ptr_type_qualifiers = malloc (sizeof(DBCC_TypeQualifier) * rv.n_ptr);
          rv.ptr_type_qualifiers[0] = tq;
          rv.code_position = a.code_position;
          memcpy (rv.ptr_type_qualifiers + 1, a.ptr_type_qualifiers, sizeof(DBCC_TypeQualifier) * a.n_ptr);
          free (a.ptr_type_qualifiers); }
pointer(rv) ::= ASTERISK(ast) opt_type_qualifier_list(tq).
        { rv.n_ptr = 1;
          rv.ptr_type_qualifiers = malloc (sizeof(DBCC_TypeQualifier));
          rv.ptr_type_qualifiers[0] = tq;
          rv.code_position = ast.code_position;
        }

opt_type_qualifier_list(o) ::= .
        { o = 0; }
opt_type_qualifier_list(o) ::= type_qualifier_list(i).
        { o = i; }

type_qualifier_list(o) ::= type_qualifier(i).
        { o = i; }
type_qualifier_list(o) ::= type_qualifier_list(a) type_qualifier(i).
        { o = a | i; }


parameter_type_list(rv) ::= parameter_list(a) COMMA ELLIPSIS.
        { rv.parameters = a;
          rv.has_varargs = true; }
parameter_type_list(rv) ::= parameter_list(a).
        { rv.parameters = a;
          rv.has_varargs = false; }

parameter_list(rv) ::= parameter_declaration(decl).
        { rv.first_declaration = rv.last_declaration = decl;
          decl->next = NULL; }
parameter_list(rv) ::= parameter_list(a) COMMA parameter_declaration(decl).
        { a.last_declaration->next = decl;
          a.last_declaration = decl;
          decl->next = NULL;
          rv = a; }

parameter_declaration(rv) ::= declaration_specifiers(type) declarator(name).
        { rv = type;
          p_declaration_append_declarator (rv, name); }
parameter_declaration(rv) ::= declaration_specifiers(type) abstract_declarator(nonname).
        { rv = type;
          p_declaration_append_declarator(rv, nonname); }
parameter_declaration(rv) ::= declaration_specifiers(type).
        { rv = type; }

opt_parameter_type_list(rv) ::= parameter_type_list(list).
        { rv = list; }
opt_parameter_type_list(rv) ::= .
        { rv.parameters.first_declaration = NULL;
          rv.parameters.last_declaration = NULL;
          rv.has_varargs = false; }

identifier_list(rv) ::= IDENTIFIER(id).
        { rv.first = rv.last = NULL;
          p_identifier_list_append (&rv, id.v_identifier); }
identifier_list(rv) ::= identifier_list(a) COMMA IDENTIFIER(id).
        { rv = a;
          p_identifier_list_append (&rv, id.v_identifier); }

type_name(type) ::= specifier_qualifier_list(q) abstract_declarator(d).
        { type = type_from_parts (context, q, d); }
type_name(type) ::= specifier_qualifier_list(q).
        { type = type_from_parts (context, q, NULL); }

abstract_declarator(rv) ::= ASTERISK(ast) opt_type_qualifier_list(tq) abstract_declarator(d).
        { rv = p_declarator_new_pointer (tq, d, ast.code_position);
          d = NULL; }

abstract_declarator(rv) ::= direct_abstract_declarator(a).
        { rv = a; a = NULL; }

direct_abstract_declarator(rv) ::= LPAREN abstract_declarator(d) RPAREN.
        { rv = d; d = NULL; }

direct_abstract_declarator(rv) ::= LBRACKET opt_type_qualifier_list(tq) RBRACKET.
        { rv = p_declarator_new_array (tq, NULL, p_declarator_new_name(NULL)); }

direct_abstract_declarator(rv) ::= LBRACKET opt_type_qualifier_list(tq) ASTERISK RBRACKET.
        { rv = p_declarator_new_varlen_array (tq, p_declarator_new_name(NULL)); }

direct_abstract_declarator(rv) ::= LBRACKET STATIC opt_type_qualifier_list(tq) assignment_expression(expr) RBRACKET.
        { rv = p_declarator_new_array (tq, expr, p_declarator_new_name(NULL));
          expr = NULL; }
direct_abstract_declarator(rv) ::= LBRACKET type_qualifier_list(tq) STATIC assignment_expression(expr) RBRACKET.
        { rv = p_declarator_new_array (tq, expr, p_declarator_new_name(NULL));
          expr = NULL; }
direct_abstract_declarator(rv) ::= LBRACKET opt_type_qualifier_list(tq) assignment_expression(expr) RBRACKET.
        { rv = p_declarator_new_array (tq, expr, p_declarator_new_name(NULL));
          expr = NULL; }

direct_abstract_declarator(rv) ::= direct_abstract_declarator(d) LBRACKET opt_type_qualifier_list(tq) RBRACKET.
        { rv = p_declarator_new_array(tq, NULL, d);
          d = NULL; }
direct_abstract_declarator(rv) ::= direct_abstract_declarator(d) LBRACKET opt_type_qualifier_list(tq) assignment_expression(expr) RBRACKET.
        { rv = p_declarator_new_array(tq, expr, d);
          d = NULL;
          expr = NULL; }
direct_abstract_declarator(rv) ::= direct_abstract_declarator(d) LBRACKET STATIC opt_type_qualifier_list(tq) assignment_expression(expr) RBRACKET.
        { rv = p_declarator_new_array(tq, expr, d);
          d = NULL;
          expr = NULL; }
direct_abstract_declarator(rv) ::= direct_abstract_declarator(d) LBRACKET type_qualifier_list(tq) STATIC assignment_expression(expr) RBRACKET.
        { rv = p_declarator_new_array(tq, expr, d);
          d = NULL;
          expr = NULL; }
direct_abstract_declarator(rv) ::= direct_abstract_declarator(d) opt_type_qualifier_list(tq) LBRACKET ASTERISK RBRACKET.
        { rv = p_declarator_new_varlen_array(tq, d);
          d = NULL; }
direct_abstract_declarator(rv) ::= LPAREN opt_parameter_type_list(plist) RPAREN.
        { rv = p_declarator_new_function(p_declarator_new_name(NULL), &plist); }
direct_abstract_declarator(rv) ::= direct_abstract_declarator(d) LPAREN opt_parameter_type_list(plist) RPAREN.
	{ rv = p_declarator_new_function(d, &plist); }

initializer(rv) ::= LBRACE initializer_list(list) opt_comma RBRACE.
        { rv = p_initializer_new_structured (&list); }
initializer(rv) ::= assignment_expression(expr).
        { rv = p_initializer_new_expr (expr); }

initializer_list(rv) ::= opt_designation(torlist) initializer(init).
        { assert(init->designators.first == NULL);
          init->designators = torlist;
          rv.first = rv.last = init; }

initializer_list(rv) ::= initializer_list(a) COMMA opt_designation(d) initializer(init).
        { assert(init->designators.first == NULL);
          init->designators = d;
          a.last->next = init;
          init->next = NULL;
          a.last = init;
          rv = a; }

opt_designation(rv) ::= designation(a).
	{ rv = a; a.first = a.last = NULL; }
opt_designation(rv) ::= .
	{ rv.first = rv.last = NULL; }

designation(rv) ::= designator_list(list) EQUALS.
	{ rv = list;
          list.first = list.last = NULL; }

designator_list(rv) ::= designator(d).
        { rv.first = rv.last = d;
          d->next = NULL; }
designator_list(rv) ::= designator_list(in) designator(d).
        { rv = in; in.first = in.last = NULL;
          rv.last->next = d;
          d->next = NULL;
          rv.last = d; }

designator(rv) ::= LBRACKET constant_expression(index) RBRACKET.
        { rv = p_designator_new_array_index (index);
          index = NULL; }
designator(rv) ::= PERIOD IDENTIFIER(id).
        { rv = p_designator_new_struct_member (id.v_identifier); }

static_assert_declaration(decl) ::= STATIC_ASSERT LPAREN constant_expression(expr) COMMA STRING_LITERAL(explanation) RPAREN SEMICOLON.
	{ decl = p_static_assertion_new (expr, &explanation.v_string_literal); }

statement(rv) ::= labeled_statement(stmt).
        { rv = stmt; }
statement(rv) ::= compound_statement(stmt).
        { rv = stmt; }
statement(rv) ::= expression_statement(stmt).
        { rv = stmt; }
statement(rv) ::= selection_statement(stmt).
        { rv = stmt; }
statement(rv) ::= iteration_statement(stmt).
        { rv = stmt; }
statement(rv) ::= jump_statement(stmt).
        { rv = stmt; }

labeled_statement(rv) ::= IDENTIFIER(id) COLON statement(stmt).
        { p_statement_list_init1 (&rv, dbcc_statement_new_label (id.v_identifier));
          p_statement_list_append_list (&rv, &stmt); }
labeled_statement(rv) ::= CASE constant_expression(value) COLON statement(stmt).
        { p_statement_list_init1 (&rv, dbcc_statement_new_case (value));
          p_statement_list_append_list (&rv, &stmt); }
labeled_statement(rv) ::= DEFAULT(def) COLON statement(stmt).
        { p_statement_list_init1 (&rv, dbcc_statement_new_default (def.code_position));
          p_statement_list_append_list (&rv, &stmt); }

compound_statement(rv) ::= LBRACE RBRACE.
        { p_statement_list_init_empty (&rv); }
compound_statement(rv) ::= LBRACE  block_item_list(stmtlist) RBRACE.
        { size_t n_child = 0;
          for (P_StatementNode *at = stmtlist.first; at != NULL; at = at->next)
            n_child++;
          DBCC_Statement **children = malloc (sizeof (DBCC_Statement *) * n_child);
          size_t i = 0;
          for (P_StatementNode *at = stmtlist.first; at != NULL; at = at->next)
            children[i++] = at->statement;
          p_statement_list_init1 (&rv, dbcc_statement_new_compound (n_child, children, true));
        }

block_item_list(rv) ::= block_item(bi).
        { rv = bi; }
block_item_list(rv) ::= block_item_list(in) block_item(bi).
        { rv = in;
          p_statement_list_append_list (&rv, &bi); }

block_item(rv) ::= declaration(a).
        { declaration_to_statement_list (context, a, &rv); }
block_item(rv) ::= statement(a).
        { rv = a; }

expression_statement(rv) ::= SEMICOLON.
        { p_statement_list_init1 (&rv, dbcc_statement_new_empty ()); }
expression_statement(rv) ::= expression(expr) SEMICOLON.
        { p_statement_list_init1 (&rv, dbcc_statement_new_expr (expr)); }

selection_statement(rv) ::= IF(i) LPAREN expression(cond) RPAREN statement(body) ELSE statement(else_body).
        { DBCC_Statement *s = dbcc_statement_new_if (cond,
                                                     statement_from_list (&body),
                                                     statement_from_list (&else_body),
                                                     i.code_position,
                                                     &context->error);
          if (s == NULL)
            FAIL();
          p_statement_list_init1 (&rv, s); }
selection_statement(rv) ::= IF(i) LPAREN expression(cond) RPAREN statement(body).
        { DBCC_Statement *s = dbcc_statement_new_if (cond,
                                                     statement_from_list (&body),
                                                     NULL,
                                                     i.code_position,
                                                     &context->error);
          if (s == NULL)
            FAIL();
          p_statement_list_init1 (&rv, s); }
selection_statement(rv) ::= SWITCH(sw) LPAREN expression(expr) RPAREN statement(body).
        { DBCC_Statement *s = dbcc_statement_new_switch (expr,
                                                         statement_from_list (&body),
                                                         sw.code_position,
                                                         &context->error);
          if (s == NULL)
            FAIL();
          p_statement_list_init1 (&rv, s); }

iteration_statement(rv) ::= WHILE(wh) LPAREN expression(expr) RPAREN statement(stmt).
        { DBCC_Statement *w = dbcc_statement_new_while (expr,
                                                        statement_from_list (&stmt),
                                                        wh.code_position,
                                                        &context->error);
          if (w == NULL)
            FAIL();
          p_statement_list_init1 (&rv, w);
        }

iteration_statement(rv) ::= DO(d) statement(stmt) WHILE LPAREN expression(expr) RPAREN SEMICOLON.
        { DBCC_Statement *dw = dbcc_statement_new_do_while (statement_from_list (&stmt),
                                                            expr,
                                                            d.code_position,
                                                            &context->error);
          if (dw == NULL) 
            FAIL();
          p_statement_list_init1 (&rv, dw); }
iteration_statement(rv) ::= FOR(fr) LPAREN expression_statement(init) expression_statement(cond) opt_expression(advance) RPAREN statement(body).
        { DBCC_Expr *expr = NULL;
          if (cond.first != NULL)
            {
              if (cond.first->next != NULL)
                assert(0);

              DBCC_Statement *cond_stmt = cond.first->statement;
              if (cond_stmt->type == DBCC_STATEMENT_EXPR)
                expr = cond_stmt->v_expr.expr;
              else
                {
                  context->error = dbcc_error_new (DBCC_ERROR_EXPECTED_EXPRESSION,
                                                   "non-expression in condition for 'for' loop");
                  dbcc_error_add_code_position (context->error, cond_stmt->base.code_position);
                  FAIL();
                }
            }
          DBCC_Statement *adv = advance == NULL ? NULL : dbcc_statement_new_expr (advance);
          DBCC_Statement *f = dbcc_statement_new_for (statement_from_list (&init),
                                                      expr,
                                                      adv,
                                                      statement_from_list(&body),
                                                      fr.code_position,
                                                      &context->error);
          if (f == NULL) 
            FAIL();
          p_statement_list_init1 (&rv, f); }

iteration_statement(rv) ::= FOR(fr) LPAREN declaration(decl) expression_statement(cond) opt_expression(advance) RPAREN statement(body).
        { DBCC_Expr *expr = NULL;
          if (cond.first != NULL)
            {
              if (cond.first->next != NULL)
                assert(0);

              DBCC_Statement *cond_stmt = cond.first->statement;
              if (cond_stmt->type == DBCC_STATEMENT_EXPR)
                expr = cond_stmt->v_expr.expr;
              else
                {
                  context->error = dbcc_error_new (DBCC_ERROR_EXPECTED_EXPRESSION,
                                                   "non-expression in condition for 'for' loop");
                  dbcc_error_add_code_position (context->error, cond_stmt->base.code_position);
                  FAIL();
                }
            }

          DBCC_Statement *adv = advance == NULL ? NULL : dbcc_statement_new_expr (advance);
          P_StatementList init;
          declaration_to_statement_list (context, decl, &init);
          DBCC_Statement *f = dbcc_statement_new_for (statement_from_list(&init),
                                                      expr,
                                                      adv,
                                                      statement_from_list(&body),
                                                      fr.code_position,
                                                      &context->error);
          if (f == NULL)
            FAIL();
          p_statement_list_init1 (&rv, f); }
jump_statement(rv) ::= GOTO(g) IDENTIFIER(id) SEMICOLON.
        { p_statement_list_init1 (&rv, dbcc_statement_new_goto (id.v_identifier, g.code_position)); }
jump_statement(rv) ::= CONTINUE(c) SEMICOLON.
        { p_statement_list_init1 (&rv, dbcc_statement_new_continue (c.code_position)); }
jump_statement(rv) ::= BREAK(b) SEMICOLON.
        { p_statement_list_init1 (&rv, dbcc_statement_new_break (b.code_position)); }
jump_statement(rv) ::= RETURN(r) SEMICOLON.
        { DBCC_Statement *statement = dbcc_statement_new_return (NULL, r.code_position, &context->error);
          if (statement == NULL)
            FAIL();
          p_statement_list_init1 (&rv, statement); }
jump_statement(rv) ::= RETURN(r) expression(expr) SEMICOLON.
        { DBCC_Statement *statement = dbcc_statement_new_return (expr, r.code_position, &context->error);
          if (statement == NULL)
            FAIL();
          p_statement_list_init1 (&rv, statement); }

external_declaration_list(rv) ::= external_declaration(a).
        { rv.first_declaration = rv.last_declaration = a; }
external_declaration_list(rv) ::= external_declaration_list(in) external_declaration(decl).
        { rv = in;
          rv.last_declaration->next = decl;
          rv.last_declaration = decl; }

translation_unit(rv) ::= external_declaration_list(list).
        { rv = list; }

external_declaration(rv) ::= function_definition(f).
        { rv = f; }
external_declaration(rv) ::= declaration(d).
        { rv = d; }

// an DBCC_Declaration, even though it doesn't fit the mould too well
function_definition(fdef) ::= declaration_specifiers(decl_specs) declarator(decl) opt_declaration_list(kr) compound_statement(body_stmt_list).
        { fdef = decl_specs;
          p_declaration_append_declarator(fdef, decl);
          decl_specs = NULL;
          if (kr.first_declaration != NULL)
            {
              assert(0);  // K+R not supported yet
              //... function must have identifier-list (not declarator list)
              //... names must match
              //... convert function arg-list into declration_list
            }
          assert(fdef->v_declaration.body == NULL);
          assert(body_stmt_list.first != NULL);
          assert(body_stmt_list.first->next == NULL);
          DBCC_Statement *body_stmt = body_stmt_list.first->statement;
          assert(body_stmt->type == DBCC_STATEMENT_COMPOUND);
          fdef->v_declaration.body = body_stmt;
        }

// only used for k+r function definitions
declaration_list(x) ::= declaration(d).
        { x.first_declaration = x.last_declaration = d; }
declaration_list(rv) ::= declaration_list(in) declaration(d).
        { rv = in;
          rv.last_declaration->next = d;
          rv.last_declaration = d; }

opt_declaration_list(rv) ::= .
        { rv.first_declaration = rv.last_declaration = NULL; }
opt_declaration_list(rv) ::= declaration_list(a).
        { rv = a; }

/*
From http://www.quut.com/c/ANSI-C-grammar-y-2011.html
---------------------------------------------- BEGIN QUOTE
ANSI C Yacc grammar

(This Yacc file is accompanied by a matching Lex file.)

In 1985, Jeff Lee published his Yacc grammar based on a
draft version of the ANSI C standard, along with a
supporting Lex specification. Tom Stockfisch reposted those
files to net.sources in 1987; as mentioned in the answer to
question 17.25 of the comp.lang.c FAQ, they used to be
available from ftp.uu.net as
usenet/net.sources/ansi.c.grammar.Z.

The version you see here has been updated based on the 2011
ISO C standard. (The previous version's Lex and Yacc files
for ANSI C9X still exist as archived copies.)

This grammar assumes that translation phases 1..5 have
already been completed, including preprocessing and _Pragma
processing. The Lex rule for string literals will perform
concatenation (translation phase 6). Transliteration of
universal character names (\uHHHH or \UHHHHHHHH) must have
been done by either the preprocessor or a replacement for
the input() macro used by Lex (or the YY_INPUT function used
by Flex) to read characters. Although comments should have
been changed to space characters during translation phase 3,
there are Lex rules for them anyway.

I want to keep this version as close to the current C
Standard grammar as possible; please let me know if you
discover discrepancies.
(There is an FAQ for this grammar that you might want to read first.)

jutta@pobox.com, 2012

Last edit: 2012-12-18 DAGwyn@aol.com

Note: There are two shift/reduce conflicts, correctly resolved by default:
  IF LPAREN expression RPAREN statement _ ELSE statement
and
  ATOMIC _ LPAREN type_name RPAREN
where "_" has been used to flag the points of ambiguity.
---------------------------------------------- END QUOTE

ABOUT THIS LEMON GRAMMAR:

  * throughout, i've added "opt_ABC" non-terminal productions
    which have grammar:
        opt_ABC ::= .
        opt_ABC ::= ABC.

  * pointer are handled slightly differently, with
    each pointer-level being its own Declarator.

  * P_* types are used as intermediaries, but
    are not exposed outside the parser.  They are defined
    in this .lemon file.  They should match the grammar.

  * During parsing, we use a lot of linked lists,
    but we switch to arrays for the exported types.

 */

%include{
typedef struct P_DeclaratorList P_DeclaratorList;
typedef struct P_DeclarationList P_DeclarationList;
typedef struct P_DesignatorList P_DesignatorList;
typedef struct P_Designator P_Designator;

typedef struct P_Initializer P_Initializer;
typedef struct P_InitializerList P_InitializerList;

typedef struct P_GenericAssociationList P_GenericAssociationList;
typedef struct P_GenericAssociation P_GenericAssociation;

typedef enum
{
  P_INITIALIZER_TYPE_SCALAR,
  P_INITIALIZER_TYPE_OBJECT,
  P_INITIALIZER_TYPE_ARRAY,
} P_InitializerType;

struct P_InitializerList
{
  P_Initializer *first;
  P_Initializer *last;
};

struct P_Initializer
{
  P_InitializerType initializer_type;
  P_Initializer *prev, *next;
  union {
    DBCC_Expr *v_scalar;
    P_InitializerList v_children;               // for objects and arrays
  };
};

struct P_GenericAssociationList
{
  P_GenericAssociation *first, *last;
};
struct P_GenericAssociation
{
  P_GenericAssociation *prev, *next;
  DBCC_Type *type;
  DBCC_Expr *expr;
};

typedef enum
{
  P_TYPE_SPECIFIER_INDEX_VOID      = 0,
  P_TYPE_SPECIFIER_INDEX_CHAR      = 1,
  P_TYPE_SPECIFIER_INDEX_INT       = 2,
  P_TYPE_SPECIFIER_INDEX_SHORT     = 3,
  P_TYPE_SPECIFIER_INDEX_LONG      = 4,
  P_TYPE_SPECIFIER_INDEX_LONG_LONG = 5,
  P_TYPE_SPECIFIER_INDEX_UNSIGNED  = 6,
  P_TYPE_SPECIFIER_INDEX_SIGNED    = 7,
  P_TYPE_SPECIFIER_INDEX_FLOAT     = 8,
  P_TYPE_SPECIFIER_INDEX_DOUBLE    = 9,
  P_TYPE_SPECIFIER_INDEX_BOOL      = 10,
  P_TYPE_SPECIFIER_INDEX_ATOMIC    = 11,
  P_TYPE_SPECIFIER_INDEX_COMPLEX   = 12,
  P_TYPE_SPECIFIER_INDEX_IMAGINARY = 13,
  P_TYPE_SPECIFIER_INDEX_TYPEDEF   = 14,
  P_TYPE_SPECIFIER_INDEX_STRUCT    = 15,
  P_TYPE_SPECIFIER_INDEX_UNION     = 16,
  P_TYPE_SPECIFIER_INDEX_ENUM      = 17
  P_TYPE_SPECIFIER_INDEX_STATIC    = 18
} PTypeSpecifierFlags;
#define N_TYPE_SPECIFIER_KEYWORDS     19

typedef struct
{
  uint8_t counts[N_TYPE_SPECIFIER_KEYWORDS];
  DBCC_Symbol *id;              // for named structs, unions, enums
  bool is_stub;                 // for forward-declared structs+unions+enums
  unsigned n_elements;          // for structs,unions,enums
  void *elements;
} P_TypeSpecifier;
#define P_TYPE_SPECIFIER_INIT \
        {{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},NULL,false,0,NULL}

static bool
p_type_specifiers_combine (P_TypeSpecifier *in_out,
                           P_TypeSpecifier *modifier)
{
  for (unsigned i = 0; i < N_TYPE_SPECIFIER_KEYWORDS; i++)
    {
      uint8_t sum = in_out->counts[i] + modifier->counts[i];
      if (sum < in_out->counts[i])
        {
          *error = DBCC_ERROR_TOO_MANY_TYPE_SPECIFIERS;
          return false;
        }
      in_out->counts[i] = sum;
    }
}
struct P_DeclarationList
{
  P_Declaration *first_declaration;
  P_Declaration *last_declaration;
};
struct P_DeclaratorList
{
  P_Declarator *first_declarator;
  P_Declarator *last_declarator;
};
typedef struct P_Declaration
{
  DBCC_TypeQualifier qualifiers;
  DBCC_TypeSpecifier specifiers;
  P_DeclaratorList declarators;
  P_Declaration *prev, *next;
};

typedef enum
{
  P_DECLARATOR_TYPE_NAME,
  P_DECLARATOR_TYPE_POINTER,
  P_DECLARATOR_TYPE_ARRAY,
  P_DECLARATOR_TYPE_VARLEN_ARRAY,
} P_DeclaratorType;

typedef struct P_Declarator
{
  P_DeclaratorType declarator_type;
  P_Declarator *prev, *next;            // only for toplevel declarator
  union {
    DBCC_Symbol *v_name;
    struct {
      DBCC_TypeQualifier qualifiers;
      P_Declarator *child;
    } v_pointer;
    struct {
      P_Declarator *child;
      DBCC_Expr *size;
    } v_array;
    struct {
      P_Declarator *child;
    } v_varlen_array;
  };
  P_Initializer *initializer;
};
static P_Declarator *
p_declarator_new_pointer (DBCC_TypeQualifier qualifiers,
                          P_Declarator *child)
{
...
}

static P_Declarator *
p_declarator_new_array   (DBCC_TypeQualifier qualifiers,
                          DBCC_Expr    *size,
                          P_Declarator *child)
{
  ...
}

static P_Declarator *
p_declarator_new_name    (DBCC_Symbol  *symbol)
{
  ...
}


static void
p_declarator_destroy     (P_Declarator *d);
{
  ...
}


static void
p_declaration_append_declarator (P_Declaration *parent,
                                 P_Declarator  *child)
{
  ...
}

typedef struct P_ExprList P_ExprList;
typedef struct P_ExprNode P_ExprNode;
struct P_ExprList
{
  P_ExprNode *first, *last;
};
struct P_ExprNode
{
  DBCC_Expr *expr;
  P_ExprNode *prev, *next;
}

typedef struct P_AlignmentSpecifier P_AlignmentSpecifier;
typedef enum
{
  P_ALIGNMENT_SPECIFIER_BY_TYPE,
  P_ALIGNMENT_SPECIFIER_BY_EXPR
} P_AlignmentSpecifierType;
struct P_AlignmentSpecifier
{
  P_AlignmentSpecifierType specifier_type;
  union {
    DBCC_Type *v_type;
    DBCC_Expr *v_expr;
  };
};


// A designator is how by-name structure members or array elements are initialized.
// Note that there's a list of these b/c you can do things like:
//     Obj a = { .x.value[4] = 42 };

struct P_Designator
{
  bool is_array;
  union {
    DBCC_Expr *v_array_index;
    DBCC_Symbol *object_member;
  };
  P_Designator *prev, *next;
};


}
////// end of "included" code

/* Conversion to Lemon was done Mar 2018 by Dave Benson */
%start_symbol translation_unit
%type generic_association           {P_GenericAssociation *}
%type optional_comma                {int}
%type enumeration_constant          {TODO}
%type declaration                   {P_Declaration *}
%type external_declaration          {P_Declaration *}
%type parameter_declaration         {P_Declaration *}
%type static_assert_declaration     {P_Declaration *}
%type struct_declaration            {P_Declaration *}

%type declarator                    {P_Declarator *}
%type direct_abstract_declarator    {P_Declarator *}
%type abstract_declarator           {P_Declarator *}
%type direct_declarator             {P_Declarator *}
%type init_declarator               {P_Declarator *}
%type struct_declarator             {P_Declarator *}
%type function_definition           {P_Declarator *}

%type designation                   {TODO}
%type designator                    {P_Designator *}
%type enumerator                    {P_Enumerator *}

%type expression                    {DBCC_Expr *}
%type additive_expression           {DBCC_Expr *}
%type and_expression                {DBCC_Expr *}
%type assignment_expression         {DBCC_Expr *}
%type cast_expression               {DBCC_Expr *}
%type conditional_expression        {DBCC_Expr *}
%type constant_expression           {DBCC_Expr *}
%type equality_expression           {DBCC_Expr *}
%type exclusive_or_expression       {DBCC_Expr *}
%type inclusive_or_expression       {DBCC_Expr *}
%type logical_and_expression        {DBCC_Expr *}
%type logical_or_expression         {DBCC_Expr *}
%type multiplicative_expression     {DBCC_Expr *}
%type postfix_expression            {DBCC_Expr *}
%type primary_expression            {DBCC_Expr *}
%type relational_expression         {DBCC_Expr *}
%type shift_expression              {DBCC_Expr *}
%type unary_expression              {DBCC_Expr *}
%type generic_selection             {DBCC_Expr *}

/* unlike the above DBCC_Expr* nonterminals, this may be  NULL */
%type opt_expression                {DBCC_Expr *}

%type initializer                   {P_Initializer *}
%type argument_expression_list      {P_ExprList}
%type block_item_list               {P_StatementList}
%type declaration_list              {P_DeclarationList}
%type designator_list               {P_DesignatorList}
%type enumerator_list               {P_EnumeratorList}
%type generic_assoc_list            {P_GenericAssociationList}
%type init_declarator_list          {P_DeclaratorList}
%type initializer_list              {P_InitializerList}
%type opt_declaration_list          {P_DeclarationList}
%type parameter_list                {P_ParameterList}
%type parameter_type_list           {P_ParameterTypeList}
%type specifier_qualifier_list      {P_SpecifierQualifierList}
%type struct_declaration_list       {P_DeclarationList}
%type struct_declarator_list        {P_DeclaratorList}
%type type_name                     {DBCC_Type *}
%type assignment_operator           {DBCC_InplaceBinaryOperator}
%type unary_operator                {DBCC_UnaryOperator}
%type identifier_list               {P_IdentifierList}

%type opt_type_qualifier_list       {DBCC_TypeQualifier}
%type type_qualifier_list           {DBCC_TypeQualifier}
%type type_qualifier                {DBCC_TypeQualifier}
%type alignment_specifier           {P_AlignmentSpecifier}
%type enum_specifier                {P_TypeSpecifier *}
%type function_specifier            {P_TypeSpecifier *}
%type storage_class_specifier       {DBCC_StorageClassSpecifier}
%type struct_specifier              {P_TypeSpecifier *}
%type type_specifier                {P_TypeSpecifier *}
%type union_specifier               {P_TypeSpecifier *}
%type declaration_specifiers        {P_DeclarationSpecifier *}
%type opt_declaration_specifiers    {P_DeclarationSpecifier *}
%type statement                     {DBCC_Statement*}
%type block_item                    {DBCC_Statement*}
%type compound_statement            {DBCC_Statement*}
%type expression_statement          {DBCC_Statement*}
%type iteration_statement           {DBCC_Statement*}
%type jump_statement                {DBCC_Statement*}
%type labeled_statement             {DBCC_Statement*}
%type selection_statement           {DBCC_Statement*}
%type opt_static                    {bool}
%type string                        {DBCC_String}
%type external_declaration_list     {P_DeclarationList}
%type translation_unit              {P_DeclarationList}

primary_expression(rv) ::= IDENTIFIER(id).
        { rv = dbcc_expr_new_symbol (id.symbol); }
primary_expression(rv) ::= I_CONSTANT(c).
        { rv = dbcc_expr_new_int_constant (c->v_int_constant); }
primary_expression(rv) ::= F_CONSTANT(c).
        { rv = dbcc_expr_new_float_constant (c->v_float_constant); }
primary_expression(rv) ::= ENUMERATION_CONSTANT(c).
        { rv = dbcc_expr_new_enum_constant (c->info.v_enumeration_constant); }
primary_expression(rv) ::= string(s).
        { rv = dbcc_expr_new_constant_string (s); s = NULL; }
primary_expression(rv) ::= LPAREN expression(e) RPAREN.
        { rv = e; e = NULL; }
primary_expression(rv) ::= generic_selection(g).
        { rv = g; g = NULL; }

enumeration_constant(rv) ::= IDENTIFIER(s).
	{ /* XXX: must verify v_symbol is valid */
          rv = s->v_symbol; }

string(rv) ::= STRING_LITERAL(s).
        { rv = s->info.v_string_literal; s->info.v_string_literal = NULL; }
string(rv) ::= FUNC_NAME(s).
        { rv = s->info.v_func_name; s->info.v_func_name = NULL; }

generic_selection(rv) ::= GENERIC LPAREN assignment_expression(expr) COMMA generic_assoc_list(list) RPAREN.
        { list = dbcc_generic_assoc_list_reverse (list);
          rv = dbcc_expr_new_generic_selection (expr, list); }

generic_assoc_list(list) ::= generic_association(assoc).
        { list = assoc; assoc->next = NULL; assoc = NULL; }
generic_assoc_list(list) ::= generic_assoc_list(in) COMMA generic_association(assoc).
        { list = assoc; assoc->next = in; in = NULL; assoc = NULL; }

generic_association(assoc) ::= type_name(name) COLON assignment_expression(expr).
        { assoc = dbcc_generic_assoc_list_new (name, expr);
          name = NULL; expr = NULL; }
generic_association(assoc) ::= DEFAULT COLON assignment_expression(expr).
        { assoc = dbcc_generic_assoc_list_new_default (name, expr);
          expr = NULL; }

postfix_expression(rv) ::= primary_expression(a).
        { rv = a; a = NULL; }
postfix_expression(rv) ::= postfix_expression(a) LBRACKET expression(expr) RBRACKET.
        { rv = dbcc_expr_new_subscript (a, expr); a = NULL; expr = NULL; }
postfix_expression(rv) ::= postfix_expression(head) LPAREN RPAREN.
        { rv = dbcc_expr_new_call (head, NULL); head = NULL; }

postfix_expression(rv) ::= postfix_expression(head) LPAREN argument_expression_list(list) RPAREN.
        { list = dbcc_argument_expression_list_reverse (list);
          rv = dbcc_expr_new_call (head, list); head = NULL; list = NULL; }

postfix_expression(rv) ::= postfix_expression(head) DOT IDENTIFIER(id).
        { rv = dbcc_expr_new_member_access(head, id->info.v_symbol);
          head = NULL; id->info.v_symbol = NULL; }

postfix_expression(rv) ::= postfix_expression(head) PTR_OP IDENTIFIER(id).
        { rv = dbcc_expr_new_pointer_access(head, id->info.v_symbol);
          head = NULL; id->info.v_symbol = NULL; }
postfix_expression(rv) ::= postfix_expression(expr) INC_OP.
        { rv = dbcc_expr_new_inplace_unary(DBCC_INPLACE_UNARY_OPERATOR_POST_INCR, expr); expr = NULL; }
postfix_expression(rv) ::= postfix_expression(expr) DEC_OP.
        { rv = dbcc_expr_new_inplace_unary(DBCC_INPLACE_UNARY_OPERATOR_POST_DECR, expr); expr = NULL; }
postfix_expression(rv) ::= LPAREN type_name(type) RPAREN LBRACE initializer_list(list) optional_comma RBRACE.
        { rv = ... }

optional_comma ::= COMMA.
optional_comma ::= .

argument_expression_list(list) ::= assignment_expression(expr).
        { list = dbcc_argument_expression_list_new (expr, NULL); expr = NULL; }
argument_expression_list(list) ::= argument_expression_list(in) COMMA assignment_expression(expr).
        { list = dbcc_argument_expression_list_new (expr, in); expr = NULL; in = NULL; }

unary_expression(out) ::= postfix_expression(in).
        { out = in; in = NULL; }

unary_expression(rv) ::= INC_OP unary_expression(expr).
        { rv = dbcc_expr_new_inplace_unary(DBCC_INPLACE_UNARY_OPERATOR_PRE_INCR, expr); expr = NULL; }
unary_expression(rv) ::= DEC_OP unary_expression(expr).
        { rv = dbcc_expr_new_inplace_unary(DBCC_INPLACE_UNARY_OPERATOR_PRE_DECR, expr); expr = NULL; }
unary_expression(rv) ::= unary_operator(op) cast_expression(expr).
        { rv = dbcc_expr_new_unary(op, expr); expr = NULL; }
unary_expression(rv) ::= SIZEOF unary_expression(expr).
        { rv = dbcc_expr_new_sizeof_expr(expr); expr = NULL; }
unary_expression(rv) ::= SIZEOF LPAREN type_name(type) RPAREN.
        { rv = dbcc_expr_new_sizeof_type(type); expr = NULL; }
unary_expression(rv) ::= ALIGNOF LPAREN type_name(type) RPAREN.
        { rv = dbcc_expr_new_alignof_type(type); expr = NULL; }

unary_operator(rv) ::= AMPERSAND.
        { rv = DBCC_UNARY_OPERATOR_REFERENCE; }
unary_operator(rv) ::= ASTERISK.
        { rv = DBCC_UNARY_OPERATOR_DEREFERENCE; }
unary_operator(rv) ::= PLUS.
        { rv = DBCC_UNARY_OPERATOR_PLUS; }
unary_operator(rv) ::= MINUS.
        { rv = DBCC_UNARY_OPERATOR_NEGATE; }
unary_operator(rv) ::= TILDE.
        { rv = DBCC_UNARY_OPERATOR_BITWISE_NOT; }
unary_operator(rv) ::= EXCLAMATION_POINT.
        { rv = DBCC_UNARY_OPERATOR_LOGICAL_NOT; }

cast_expression(rv) ::= unary_expression(expr).
        { rv = expr; expr = NULL; }
cast_expression(rv) ::= LPAREN type_name(type) RPAREN cast_expression(expr).
        { rv = dbcc_expr_new_cast (type, expr); type = NULL; expr = NULL; }

multiplicative_expression(rv) ::= cast_expression(expr).
        { rv = expr; expr = NULL; }
multiplicative_expression(rv) ::= multiplicative_expression(a) ASTERISK cast_expression(b).
        { rv = dbcc_expr_new_binary_operator (DBCC_BINARY_OPERATOR_MUL, a, b);
          a = b = NULL; }
multiplicative_expression(rv) ::= multiplicative_expression(a) SLASH cast_expression(b).
        { rv = dbcc_expr_new_binary_operator (DBCC_BINARY_OPERATOR_DIV, a, b);
          a = b = NULL; }
multiplicative_expression(rv) ::= multiplicative_expression(a) PERCENT cast_expression(b).
        { rv = dbcc_expr_new_binary_operator (DBCC_BINARY_OPERATOR_REMAINDER, a, b);
          a = b = NULL; }

additive_expression(rv) ::= multiplicative_expression(expr).
        { rv = expr; expr = NULL; }
additive_expression(rv) ::= additive_expression(a) PLUS multiplicative_expression(b).
        { rv = dbcc_expr_new_binary_operator (DBCC_BINARY_OPERATOR_ADD, a, b);
          a = b = NULL; }
additive_expression(rv) ::= additive_expression(a) MINUS multiplicative_expression(b).
        { rv = dbcc_expr_new_binary_operator (DBCC_BINARY_OPERATOR_SUB, a, b);
          a = b = NULL; }

shift_expression(rv) ::= additive_expression(expr).
        { rv = expr; expr = NULL; }
shift_expression(rv) ::= shift_expression(a) LEFT_OP additive_expression(b).
        { rv = dbcc_expr_new_binary_operator (DBCC_BINARY_OPERATOR_SHIFT_LEFT, a, b);
          a = b = NULL; }
shift_expression(rv) ::= shift_expression(a) RIGHT_OP additive_expression(b).
        { rv = dbcc_expr_new_binary_operator (DBCC_BINARY_OPERATOR_SHIFT_RIGHT, a, b);
          a = b = NULL; }

relational_expression(rv) ::= shift_expression(expr).
        { rv = expr; expr = NULL; }
relational_expression(rv) ::= relational_expression(a) LT shift_expression(b).
        { rv = dbcc_expr_new_binary_operator (DBCC_BINARY_OPERATOR_LESS_THAN, a, b);
          a = b = NULL; }
relational_expression(rv) ::= relational_expression(a) GT shift_expression(b).
        { rv = dbcc_expr_new_binary_operator (DBCC_BINARY_OPERATOR_GREATER_THAN, a, b);
          a = b = NULL; }
relational_expression(rv) ::= relational_expression(a) LE shift_expression(b).
        { rv = dbcc_expr_new_binary_operator (DBCC_BINARY_OPERATOR_LE, a, b);
          a = b = NULL; }
relational_expression(rv) ::= relational_expression(a) GE shift_expression(b).
        { rv = dbcc_expr_new_binary_operator (DBCC_BINARY_OPERATOR_GE, a, b);
          a = b = NULL; }

equality_expression(rv) ::= relational_expression(expr).
        { rv = expr; expr = NULL; }
equality_expression(rv) ::= equality_expression(a) EQ_OP relational_expression(b).
        { rv = dbcc_expr_new_binary_operator (DBCC_BINARY_OPERATOR_EQUALS, a, b);
          a = b = NULL; }
equality_expression(rv) ::= equality_expression(a) NE_OP relational_expression(b).
        { rv = dbcc_expr_new_binary_operator (DBCC_BINARY_OPERATOR_NOT_EQUALS, a, b);
          a = b = NULL; }

and_expression(rv) ::= equality_expression(expr).
        { rv = expr; expr = NULL; }
and_expression(rv) ::= and_expression(a) AMPERSAND equality_expression(b).
        { rv = dbcc_expr_new_binary_operator (DBCC_BINARY_OPERATOR_BITWISE_AND, a, b);
          a = b = NULL; }

exclusive_or_expression(rv) ::= and_expression(expr).
        { rv = expr; expr = NULL; }
exclusive_or_expression(rv) ::= exclusive_or_expression(a) CARAT and_expression(b).
        { rv = dbcc_expr_new_binary_operator (DBCC_BINARY_OPERATOR_BITWISE_XOR, a, b);
          a = b = NULL; }

inclusive_or_expression(rv) ::= exclusive_or_expression(expr).
        { rv = expr; expr = NULL; }
inclusive_or_expression(rv) ::= inclusive_or_expression(a) VERTICAL_BAR exclusive_or_expression(b).
        { rv = dbcc_expr_new_binary_operator (DBCC_BINARY_OPERATOR_BITWISE_OR, a, b);
          a = b = NULL; }

logical_and_expression(rv) ::= inclusive_or_expression(expr).
        { rv = expr; expr = NULL; }
logical_and_expression(rv) ::= logical_and_expression(a) AND_OP inclusive_or_expression(b).
        { rv = dbcc_expr_new_binary_operator (DBCC_BINARY_OPERATOR_LOGICAL_AND, a, b);
          a = b = NULL; }

logical_or_expression(rv) ::= logical_and_expression(expr).
        { rv = expr; expr = NULL; }
logical_or_expression(rv) ::= logical_or_expression(a) OR_OP logical_and_expression(b).
        { rv = dbcc_expr_new_binary_operator (DBCC_BINARY_OPERATOR_LOGICAL_OR, a, b);
          a = b = NULL; }

conditional_expression(rv) ::= logical_or_expression(expr).
        { rv = expr; expr = NULL; }
conditional_expression(rv) ::= logical_or_expression(a) QUESTION_MARK expression(b) COLON conditional_expression(c).
        { rv = dbcc_expr_new_ternary (a, b, c);
          a = b = c = NULL; }

assignment_expression(rv) ::= conditional_expression(expr).
        { rv = expr; expr = NULL; }
assignment_expression(rv) ::= unary_expression(a) assignment_operator(op) assignment_expression(b).
	{ rv = dbcc_expr_new_inplace_binary (op, a, b); a = b = NULL; }

assignment_operator(rv) ::= EQUALS.
        { rv = DBCC_INPLACE_BINARY_OPERATOR_ASSIGN; }
assignment_operator(rv) ::= MUL_ASSIGN.
        { rv = DBCC_INPLACE_BINARY_OPERATOR_MUL_ASSIGN; }
assignment_operator(rv) ::= DIV_ASSIGN.
        { rv = DBCC_INPLACE_BINARY_OPERATOR_DIV_ASSIGN; }
assignment_operator(rv) ::= REM_ASSIGN.
        { rv = DBCC_INPLACE_BINARY_OPERATOR_REM_ASSIGN; }
assignment_operator(rv) ::= ADD_ASSIGN.
        { rv = DBCC_INPLACE_BINARY_OPERATOR_ADD_ASSIGN; }
assignment_operator(rv) ::= SUB_ASSIGN.
        { rv = DBCC_INPLACE_BINARY_OPERATOR_SUB_ASSIGN; }
assignment_operator(rv) ::= LEFT_SHIFT_ASSIGN.
        { rv = DBCC_INPLACE_BINARY_OPERATOR_LEFT_SHIFT_ASSIGN; }
assignment_operator(rv) ::= RIGHT_SHIFT_ASSIGN.
        { rv = DBCC_INPLACE_BINARY_OPERATOR_RIGHT_SHIFT_ASSIGN; }
assignment_operator(rv) ::= AND_ASSIGN.
        { rv = DBCC_INPLACE_BINARY_OPERATOR_AND_ASSIGN; }
assignment_operator(rv) ::= XOR_ASSIGN.
        { rv = DBCC_INPLACE_BINARY_OPERATOR_XOR_ASSIGN; }
assignment_operator(rv) ::= OR_ASSIGN.
        { rv = DBCC_INPLACE_BINARY_OPERATOR_OR_ASSIGN; }

expression(rv) ::= assignment_expression(expr).
        { rv = expr; expr = NULL; }
expression(rv) ::= expression(a) COMMA assignment_expression(b).
        { rv = dbcc_expr_new_binary_operator (DBCC_BINARY_OPERATOR_COMMA, a, b);
          a = b = NULL; }

constant_expression(rv) ::= conditional_expression(a).
	{ if (a->constant_value == NULL)
            {
              ...
            }
          rv = a;
          a = NULL;
        }

opt_expression(o) ::= expression(i).
        { o = i; i = NULL; }
opt_expression(o) ::= .
        { o = NULL; }

declaration(rv) ::= declaration_specifiers(specs) SEMICOLON.
        { ... }
declaration(rv) ::= declaration_specifiers(specs) init_declarator_list(names) SEMICOLON.
        { ... }
declaration(rv) ::= static_assert_declaration(sadecl).
        { ... }

opt_declaration_specifiers(rv) ::= declaration_specifiers(a).
        { rv = a; a = NULL; }
opt_declaration_specifiers(rv) ::= .
        { rv = dbcc_declaration_specifiers_new (); }

declaration_specifiers(rv) ::= storage_class_specifier(scs) opt_declaration_specifiers(a).
        { rv = a; a = NULL;
          rv->storage_class_specifiers |= scs; }
declaration_specifiers(rv) ::= type_specifier(ts) opt_declaration_specifiers(a).
        { rv = a; a = NULL;
          dbcc_declaration_specifiers_append_type_specifier(rv, ts); 
          ts = NULL; }
declaration_specifiers(rv) ::= type_qualifier(tq) opt_declaration_specifiers(a).
        { rv = a; a = NULL;
          rv->type_qualifiers |= tq; }
declaration_specifiers(rv) ::= alignment_specifier(s) opt_declaration_specifiers(a).
        { rv = a; a = NULL;
          dbcc_declaration_specifiers_append_alignment_specifier(s); s = NULL; }
declaration_specifiers(rv) ::= function_specifier(fspec).
        { rv->function_specifiers |= fspec; }

init_declarator_list(list) ::= init_declarator(d).
        { list.first = list.last = d;
          d->next = NULL; }
init_declarator_list(list) ::= init_declarator_list(a) COMMA init_declarator(d).
        { list = a;
          a.first = a.last = NULL;
          d->next = NULL;
          list.last->next = d;
          d->next = NULL;
          list.last = d; }

init_declarator(rv) ::= declarator(decl) EQUALS initializer(init).
        { assert(decl->initializer == NULL);
          decl->initializer = init;
          rv = decl;
          decl = NULL;
          init = NULL; }
init_declarator(rv) ::= declarator(decl).
        { rv = decl;
          decl = NULL; }

storage_class_specifier(rv) ::= TYPEDEF.
        { rv = DBCC_STORAGE_CLASS_SPECIFIER_TYPEDEF; }
storage_class_specifier(rv) ::= EXTERN.
        { rv = DBCC_STORAGE_CLASS_SPECIFIER_EXTERN; }
storage_class_specifier(rv) ::= STATIC.
        { rv = DBCC_STORAGE_CLASS_SPECIFIER_STATIC; }
storage_class_specifier(rv) ::= THREAD_LOCAL.
        { rv = DBCC_STORAGE_CLASS_SPECIFIER_THREAD_LOCAL; }
storage_class_specifier(rv) ::= AUTO.
        { rv = DBCC_STORAGE_CLASS_SPECIFIER_AUTO; }
storage_class_specifier(rv) ::= REGISTER.
        { rv = DBCC_STORAGE_CLASS_SPECIFIER_REGISTER; }

type_specifier(rv) ::= VOID.
        { rv = DBCC_TYPE_SPECIFIER_INIT;
          rv.flags |= DBCC_TYPE_SPECIFIER_FLAG_VOID; }
type_specifier(rv) ::= CHAR.
        { rv = DBCC_TYPE_SPECIFIER_INIT;
          rv.flags |= DBCC_TYPE_SPECIFIER_FLAG_CHAR; }
type_specifier(rv) ::= INT.
        { rv = DBCC_TYPE_SPECIFIER_INIT;
          rv.flags |= DBCC_TYPE_SPECIFIER_FLAG_INT; }
type_specifier(rv) ::= LONG.
        { rv = DBCC_TYPE_SPECIFIER_INIT;
          rv.flags |= DBCC_TYPE_SPECIFIER_FLAG_LONG; }
type_specifier(rv) ::= FLOAT.
        { rv = DBCC_TYPE_SPECIFIER_INIT;
          rv.flags |= DBCC_TYPE_SPECIFIER_FLAG_FLOAT; }
type_specifier(rv) ::= DOUBLE.
        { rv = DBCC_TYPE_SPECIFIER_INIT;
          rv.flags |= DBCC_TYPE_SPECIFIER_FLAG_DOUBLE; }
type_specifier(rv) ::= SIGNED.
        { rv = DBCC_TYPE_SPECIFIER_INIT;
          rv.flags |= DBCC_TYPE_SPECIFIER_FLAG_SIGNED; }
type_specifier(rv) ::= UNSIGNED.
        { rv = DBCC_TYPE_SPECIFIER_INIT;
          rv.flags |= DBCC_TYPE_SPECIFIER_FLAG_UNSIGNED; }
type_specifier(rv) ::= BOOL.
        { rv = DBCC_TYPE_SPECIFIER_INIT;
          rv.flags |= DBCC_TYPE_SPECIFIER_FLAG_BOOL; }
type_specifier(rv) ::= COMPLEX.
        { rv = DBCC_TYPE_SPECIFIER_INIT;
          rv.flags |= DBCC_TYPE_SPECIFIER_FLAG_COMPLEX; }
type_specifier(rv) ::= IMAGINARY.
        { rv = DBCC_TYPE_SPECIFIER_INIT;
          rv.flags |= DBCC_TYPE_SPECIFIER_FLAG_IMAGINARY; }
type_specifier(rv) ::= ATOMIC LPAREN type_name(type) RPAREN.
        { rv = DBCC_TYPE_SPECIFIER_INIT;
          rv.atomic_type = type; type = NULL; }
type_specifier(rv) ::= struct_specifier(a).
        { rv = a; a = NULL; }
type_specifier(rv) ::= union_specifier(a).
        { rv = a; a = NULL; }
type_specifier(rv) ::= enum_specifier(a).
        { rv = a; a = NULL; }
type_specifier(rv) ::= TYPEDEF_NAME(t).
	{ rv = dbcc_type_specifier_new_type (t->info.v_type); t->info.v_type = NULL; }

struct_specifier ::= STRUCT LBRACE struct_declaration_list(list) RBRACE.
        { rv = dbcc_type_specifier_new_struct (NULL, list); }
struct_specifier ::= STRUCT IDENTIFIER(id) LBRACE struct_declaration_list(list) RBRACE.
        { rv = dbcc_type_specifier_new_struct (id->str, list); }
struct_specifier ::= STRUCT IDENTIFIER.
        { rv = dbcc_type_specifier_new_struct_stub (id->str); }
union_specifier  ::= UNION LBRACE struct_declaration_list(list) RBRACE.
        { rv = dbcc_type_specifier_new_union (NULL, list); }
union_specifier  ::= UNION IDENTIFIER(id) LBRACE struct_declaration_list(list) RBRACE.
        { rv = dbcc_type_specifier_new_union (id->str, list); }
union_specifier  ::= UNION IDENTIFIER.
        { rv = dbcc_type_specifier_new_union_stub (id->str); }

struct_declaration_list(rv) ::= struct_declaration(a).
        { rv.first = rv.last = NULL;
          dbcc_declaration_list_append(rv, a);
          a = NULL; }
struct_declaration_list(rv) ::= struct_declaration_list(in) struct_declaration(a).
        { rv = in;
          in.first = in.last = NULL;
          dbcc_declaration_list_append(rv, a);
          a = NULL; }

struct_declaration(rv) ::= specifier_qualifier_list(in) SEMICOLON.   /* for anonymous struct/union within structs */
        {
          ... assert specifier_qualifier_list must be a struct or union (non-stub)
          ...
        }
struct_declaration(rv) ::= specifier_qualifier_list struct_declarator_list SEMICOLON.
        {
          ...
        }
struct_declaration(rv) ::= static_assert_declaration(sadecl).
	{
          ...
	}

specifier_qualifier_list(rv) ::= type_specifier(ts) specifier_qualifier_list(a).
        { rv = a; a = NULL;
          if (!dbcc_type_specifiers_combine (ts, rv.type_specifier, &tmp))
            {
              ...
            }
          a.first = a.last = NULL;
          ts.elements = NULL;
          ts.n_elements = 0;
          ts.id = NULL;
        }

specifier_qualifier_list(rv) ::= type_specifier(ts).
	{ rv = dbcc_specifier_qualifier_list_new_from_type_specifier (ts);
          ts.elements = NULL;
          ts.n_elements = 0;
          ts.id = NULL; }

specifier_qualifier_list(rv) ::= type_qualifier(tq) specifier_qualifier_list(a).
        { rv = a;
          rv.type_qualifier |= tq;
          a.first = a.last = NULL; }
specifier_qualifier_list(rv) ::= type_qualifier(tq).
	{ rv = dbcc_specifier_qualifier_list_new ();
          rv.type_qualifier |= tq; }

// a comma-separated list of variables with qualifiers,
// in an expression like 'int a, *b'
// the whole thing is a "declaration" and "a" and "b" are "declarators".
struct_declarator_list(list) ::= struct_declarator(decl).
        { list = dbcc_declarator_list_new ();
          dbcc_declarator_list_append (list, decl);
          decl = NULL; }
struct_declarator_list(list) ::= struct_declarator_list(in) COMMA struct_declarator(decl).
        { list = in;
          in.first = in.last = NULL;
          dbcc_declarator_list_append (list, decl);
          decl = NULL; }

struct_declarator(sdecl) ::= COLON constant_expression(bitcount).
        { DBCC_Declarator *tmp = dbcc_declarator_new ();
          tmp->bitcount_expr = bitcount;  // verify constant???
          sdecl = tmp;
          bitcount = NULL; }
struct_declarator(sdecl) ::= declarator(decl) COLON constant_expression(bitcount).
        { decl->bitcount_expr = bitcount;  // verify constant???
          sdecl = decl;
          decl = NULL;
          bitcount = NULL; }
struct_declarator(sdecl) ::= declarator(decl).
        { sdecl = decl;
          decl = NULL; }

enum_specifier(rv) ::= ENUM opt_identifier(id) LBRACE enumerator_list(list) opt_comma RBRACE.
        { ... }

enumerator_list(rv) ::= enumerator(e).
        { e->next = NULL; rv.first = rv.last = e; e = NULL; }
enumerator_list(rv) ::= enumerator_list(a) COMMA enumerator(e).
        { if (a.first == NULL)
            a.first = e;
          else
            a.last->next = e;
          a.last = e;
          e.next = NULL; }

// an enumeration value, with value either implicit (assigned automatically)
// or explicit (derived from a constant expression).
enumerator(rv) ::= enumeration_constant(c) EQUALS constant_expression(v).
        { rv = dbcc_enum_value_new (c, v); c = NULL; v = NULL; }
enumerator(rv) ::= enumeration_constant(c).
        { rv = dbcc_enum_value_new (c, NULL); c = NULL; }

type_qualifier(rv) ::= CONST.
        { rv = DBCC_TYPE_QUALIFIER_CONST; }
type_qualifier(rv) ::= RESTRICT.
        { rv = DBCC_TYPE_QUALIFIER_RESTRICT; }
type_qualifier(rv) ::= VOLATILE.
        { rv = DBCC_TYPE_QUALIFIER_VOLATILE; }
type_qualifier(rv) ::= ATOMIC.
        { rv = DBCC_TYPE_QUALIFIER_ATOMIC; }

function_specifier(rv) ::= INLINE.
        { rv = DBCC_FUNCTION_SPECIFIER_INLINE; }
function_specifier(rv) ::= NORETURN.
        { rv = DBCC_FUNCTION_SPECIFIER_NORETURN; }

alignment_specifier(rv) ::= ALIGNAS LPAREN type_name(type) RPAREN.
        { rv.specifier_type = P_ALIGNMENT_SPECIFIER_BY_TYPE;
          rv.v_type = type;
          type = NULL; }
alignment_specifier(rv) ::= ALIGNAS LPAREN constant_expression(expr) RPAREN.
        { rv.specifier_type = P_ALIGNMENT_SPECIFIER_BY_EXPR;
          rv.v_expr = expr;
          expr = NULL; }

declarator(out) ::= pointer(ptr) direct_declarator(in).
        { out = in; in = NULL;
          dbcc_declarator_prepend_pointer_spec(out, ptr.n_ptr, ptr.ptr_type_qualifiers); }
declarator(out) ::= direct_declarator(in).
        { out = in; in = NULL; }

direct_declarator(decl) ::= IDENTIFIER(id).
        { decl = dbcc_declarator_new (id->v_symbol); id->info.v_symbol = NULL; }

direct_declarator(decl) ::= LPAREN declarator(in) RPAREN.
        { decl = in; in = NULL; }
direct_declarator(decl) ::= direct_declarator(in) LBRACKET opt_type_qualifier_list(tq) RBRACKET.
        { decl = in; dbcc_declarator_append_array (decl, tq, NULL); in = NULL; }

direct_declarator(decl) ::= direct_declarator(in) LBRACKET opt_static(os1) opt_type_qualifier_list(tq) opt_static(os2) assignment_expression(index_expr) RBRACKET.
        { if (os1 && os2)
            {
              ...     //error static must only appear once
            }
          if (os1 || os2)
            {
              ...     //index_expr must be constant!
            }
          decl = in;
          dbcc_declarator_append_array (decl, tq, index_expr);
          in = NULL;
        }
direct_declarator(decl) ::= direct_declarator(in) LBRACKET opt_type_qualifier_list(tq) ASTERISK RBRACKET.
        { decl = in;
          dbcc_declarator_append_variable_length_array (decl, tq);
          in = NULL; }
direct_declarator(decl) ::= direct_declarator(in) LPAREN parameter_type_list(plist) RPAREN.
        { decl = in;
          in = NULL;
          dbcc_declarator_append_function (decl, plist.first);
          plist.first = plist.last = NULL;
        }
direct_declarator(decl) ::= direct_declarator(in) LPAREN RPAREN.
        { decl = in;
          in = NULL;
          dbcc_declarator_append_function_no_args (decl);
        }
direct_declarator(decl) ::= direct_declarator(in) LPAREN identifier_list(idlist) RPAREN.
        { decl = in;
          in = NULL;
          unsigned n_symbols = 0;
          for (DBCC_P_IdentifierList *at = idlist.first; at; at = at->next)
            n_symbols++;
          unsigned i = 0;
          symbols = malloc (sizeof (DBCC_Symbol *) * n_symbols);
          for (DBCC_P_IdentifierList *at = idlist.first; at; at = at->next)
            symbols[i++] = at->symbol;
          dbcc_declarator_append_function_kr (decl, n_symbols, symbols);
        }

opt_identifier(rv) ::= IDENTIFIER(id).
        { rv = id.v_symbol; id.v_symbol = NULL; }
opt_identifier(rv) ::= .
        { rv = NULL; }
opt_static(rv) ::= .
        { rv = false; }
opt_static(rv) ::= STATIC.
        { rv = true; }
opt_comma ::= .
opt_comma ::= COMMA.

pointer(rv) ::= ASTERISK opt_type_qualifier_list(tq) pointer(a).
        { rv.n_ptr = a.n_ptr + 1
          rv.ptr_type_qualifiers = malloc (sizeof(DBCC_TypeQualifier) * rv.n_ptr);
          rv.ptr_type_qualifiers[0] = tq;
          memcpy (rv.ptr_type_qualifiers + 1, a.ptr_type_qualifiers, sizeof(DBCC_TypeQualifier) * a.n_ptr); }
pointer(rv) ::= ASTERISK opt_type_qualifier_list(tq).
        { rv.n_ptr = 1;
          rv.ptr_type_qualifiers = malloc (sizeof(DBCC_TypeQualifier));
          rv.ptr_type_qualifiers[0] = tq;
        }

opt_type_qualifier_list(o) ::= .
        { o = 0; }
opt_type_qualifier_list(o) ::= type_qualifier_list(i).
        { o = i; }

type_qualifier_list(o) ::= type_qualifier(i).
        { o = i; }
type_qualifier_list(o) ::= type_qualifier_list(a) type_qualifier(i).
        { o = a | i; }


parameter_type_list(rv) ::= parameter_list(a) COMMA ELLIPSIS.
        { rv = a;
          a = NULL;
          rv->is_vararg = true; }
parameter_type_list(rv) ::= parameter_list(a).
        { rv = a;
          a = NULL; }

parameter_list(rv) ::= parameter_declaration(decl).
        { rv.first = rv.last = decl;
          decl->next = NULL;
          decl = NULL; }
parameter_list(rv) ::= parameter_list(a) COMMA parameter_declaration(decl).
        { if (a.first == NULL)
            a.first = decl;
          else
            a.last->next = decl;
          a.last = decl;
          rv = a;
          a.first = a.last = NULL;
          decl = NULL; }

parameter_declaration(rv) ::= declaration_specifiers(type) declarator(name).
        { ... }
parameter_declaration(rv) ::= declaration_specifiers abstract_declarator.
        { ... }
parameter_declaration(rv) ::= declaration_specifiers.
        { ... }

opt_parameter_type_list(rv) ::= parameter_type_list(list).
        { rv = list; list = NULL; }
opt_parameter_type_list(rv) ::= .
        { rv = NULL; }

identifier_list(rv) ::= IDENTIFIER(id).
        { rv = { NULL, NULL };
          dbcc_p_identifier_list_append (&rv, id->info.v_symbol); }
identifier_list(rv) ::= identifier_list(a) COMMA IDENTIFIER(id).
        { rv = a; a.first = a.last = NULL;
          dbcc_p_identifier_list_append (&rv, id->info.v_symbol); }

type_name ::= specifier_qualifier_list abstract_declarator.
type_name ::= specifier_qualifier_list.

abstract_declarator(rv) ::= ASTERISK opt_type_qualifier_list(tq) abstract_declarator(d).
        { rv = dbcc_declarator_new_pointer (tq, d);
          d = NULL; }

abstract_declarator(rv) ::= direct_abstract_declarator(a).
        { rv = a; a = NULL; }

direct_abstract_declarator(rv) ::= LPAREN abstract_declarator(d) RPAREN.
        { rv = d; d = NULL; }

direct_abstract_declarator(rv) ::= LBRACKET opt_type_qualifier_list(tq) RBRACKET.
        { rv = dbcc_declarator_new_array (dbcc_declarator_new_name(NULL), tq, NULL); }

direct_abstract_declarator(rv) ::= LBRACKET ASTERISK RBRACKET.
        { rv = dbcc_declarator_new_varlen_array (dbcc_declarator_new_name(NULL)); }
direct_abstract_declarator(rv) ::= LBRACKET STATIC opt_type_qualifier_list(tq) assignment_expression(expr) RBRACKET.
        { rv = dbcc_declarator_new_array (dbcc_declarator_new_name(NULL), tq, expr);
          expr = NULL; }
direct_abstract_declarator(rv) ::= LBRACKET type_qualifier_list(tq) STATIC assignment_expression(expr) RBRACKET.
        { rv = dbcc_declarator_new_array (dbcc_declarator_new_name(NULL), tq, expr);
          expr = NULL; }
direct_abstract_declarator(rv) ::= LBRACKET opt_type_qualifier_list(tq) assignment_expression(expr) RBRACKET.
        { rv = dbcc_declarator_new_array (dbcc_declarator_new_name(NULL), tq, expr);
          expr = NULL; }

direct_abstract_declarator(rv) ::= direct_abstract_declarator(d) LBRACKET opt_type_qualifier_list(tq) RBRACKET.
        { rv = dbcc_declarator_new_array(d, tq, NULL);
          d = NULL; }
direct_abstract_declarator(rv) ::= direct_abstract_declarator(d) LBRACKET opt_type_qualifier_list(tq) assignment_expression(expr) RBRACKET.
        { rv = dbcc_declarator_new_array(d, tq, expr);
          d = NULL;
          expr = NULL; }
direct_abstract_declarator(rv) ::= direct_abstract_declarator(d) LBRACKET STATIC opt_type_qualifier_list(tq) assignment_expression(expr) RBRACKET.
        { rv = p_declarator_new_array(d, tq, expr);
          d = NULL;
          expr = NULL; }
direct_abstract_declarator(rv) ::= direct_abstract_declarator(d) LBRACKET type_qualifier_list(tq) STATIC assignment_expression(expr) RBRACKET.
        { rv = p_declarator_new_array(d, tq, expr);
          d = NULL;
          expr = NULL; }

direct_abstract_declarator(rv) ::= direct_abstract_declarator(d) LBRACKET ASTERISK RBRACKET.
        { rv = p_declarator_new_varlen_array(d);
          d = NULL; }
direct_abstract_declarator(rv) ::= LPAREN opt_parameter_type_list(plist) RPAREN.
        { rv = p_function_declarator_new(p_declarator_new_name(NULL), plist);
          plist.first = plist.last = NULL; }
direct_abstract_declarator(rv) ::= direct_abstract_declarator(d) LPAREN opt_parameter_type_list(plist) RPAREN.
	{ rv = p_function_declarator_new(d, plist);
          d = NULL;
          plist.first = plist.last = NULL; }

initializer(rv) ::= LBRACE initializer_list(list) opt_comma RBRACE.
        { rv = p_initializer_new_structured (list);
          list.first = list.last = NULL; }
initializer_list(rv) ::= assignment_expression(expr).
        { rv = p_initializer_new_expr (expr); }

initializer_list ::= opt_designation(torlist) initializer(init).
        { assert(init->designator_list.first == NULL);
          init->designator_list = torlist;
          torlist.first = torlist.last = NULL;
          rv.first = rv.last = init;
          init->next = NULL;
          init = NULL; }

initializer_list(rv) ::= initializer_list(a) COMMA opt_designation(d) initializer(init).
        { assert(init->designator_list.first == NULL);
          init->designator_list = d;
          d.first = d.last = NULL;
          a.last->next = init;
          init->next = NULL;
          a.last = init;
          rv = a;
          a.first = a.last = NULL; }

opt_designation(rv) ::= designation(a).
	{ rv = a; a.first = a.last = NULL; }
opt_designation(rv) ::= .
	{ rv.first = rv.last = NULL; }

designation(rv) ::= designator_list(list) EQUALS.
	{ rv = list;
          list.first = list.last = NULL; }

designator_list(rv) ::= designator(d).
        { rv.first = rv.last = d;
          d->next = NULL; }
designator_list(rv) ::= designator_list(in) designator(d).
        { rv = in; in.first = in.last = NULL;
          rv.last->next = d;
          d->next = NULL;
          rv.last = d; }

designator(rv) ::= LBRACKET constant_expression(index) RBRACKET.
        { rv = p_designator_new_array_subscript (index);
          index = NULL; }
designator(rv) ::= DOT IDENTIFIER(id).
        { rv = p_designator_new_member_access (id->v_symbol);
          index = NULL; }

static_assert_declaration(decl) ::= STATIC_ASSERT LPAREN constant_expression(expr) COMMA STRING_LITERAL(explanation) RPAREN SEMICOLON.
	{ ... }

statement(rv) ::= labeled_statement(stmt).
        { rv = stmt; stmt = NULL; }
statement(rv) ::= compound_statement(stmt).
        { rv = stmt; stmt = NULL; }
statement(rv) ::= expression_statement(stmt).
        { rv = stmt; stmt = NULL; }
statement(rv) ::= selection_statement(stmt).
        { rv = stmt; stmt = NULL; }
statement(rv) ::= iteration_statement(stmt).
        { rv = stmt; stmt = NULL; }
statement(rv) ::= jump_statement(stmt).
        { rv = stmt; stmt = NULL; }

labeled_statement(rv) ::= IDENTIFIER(id) COLON statement(stmt).
        { rv = dbcc_statement_new_p_labelled (id->info.v_symbol, stmt);
          stmt = NULL; }
labeled_statement(rv) ::= CASE constant_expression(value) COLON statement(stmt).
        { rv = dbcc_statement_new_p_case (value, stmt);
          value = NULL;
          stmt = NULL; }
labeled_statement(rv) ::= DEFAULT COLON statement(stmt).
        { rv = dbcc_statement_new_default (stmt);
          stmt = NULL; }

compound_statement ::= LBRACE RBRACE.
        { rv = dbcc_statement_new_compound (0, NULL); }
compound_statement ::= LBRACE  block_item_list(stmtlist) RBRACE.
        // XXX: use natural list instead???
        { size_t n_child = 0;
          for (DBCC_Statement *at = stmtlist->first_child; at != NULL; at = at->next)
            n_child++;
          DBCC_Statement **children = malloc (sizeof (DBCC_Statement *) * n_child);
          size_t i = 0;
          for (DBCC_Statement *at = stmtlist->first_child; at != NULL; at = at->next)
            children[i++] = at;
          rv = dbcc_statement_new_compound (n_child, children);
          stmtlist.first = stmtlist.last = NULL; }

block_item_list(rv) ::= block_item(bi).
        { rv.first = rv.last = bi;
          bi->next = NULL; }
block_item_list(rv) ::= block_item_list(in) block_item(bi).
        { rv.last->next = bi;
          rv.last = bi;
          bi->next = NULL; }

block_item(rv) ::= declaration(a).
        { rv = a; a = NULL; }
block_item(rv) ::= statement(a).
        { rv = a; a = NULL; }

expression_statement ::= SEMICOLON.
        { rv = dbcc_statement_new_empty (); }
expression_statement ::= expression(expr) SEMICOLON.
        { rv = dbcc_statement_new_expr (expr);
          expr = NULL; }

selection_statement(rv) ::= IF LPAREN expression(cond) RPAREN statement(body) ELSE statement(else_body).
        { rv = dbcc_statement_new_if (cond, body, else_body);
          cond = NULL;
          body = else_body = NULL; }
selection_statement(rv) ::= IF LPAREN expression(cond) RPAREN statement(body).
        { rv = dbcc_statement_new_if (cond, body, else_body);
          cond = NULL;
          body = NULL; }
selection_statement(rv) ::= SWITCH LPAREN expression(expr) RPAREN statement(body).
        { rv = dbcc_statement_new_switch (expr, body);
          expr = NULL; body = NULL; }

iteration_statement(rv) ::= WHILE LPAREN expression(expr) RPAREN statement(stmt).
        { rv = dbcc_statement_new_while (expr, stmt);
          expr = NULL;
          stmt = NULL; }

iteration_statement(rv) ::= DO statement(stmt) WHILE LPAREN expression(expr) RPAREN SEMICOLON.
        { rv = dbcc_statement_new_do_while (stmt, expr);
          expr = NULL;
          stmt = NULL; }
iteration_statement(rv) ::= FOR LPAREN expression_statement(init) expression_statement(cond) opt_expression(advance) RPAREN statement(body).
        { rv = dbcc_statement_new_for (NULL, init, cond, advance, body);
          init = NULL;
          cond = NULL;
          advance = NULL;
          body = NULL; }
iteration_statement(rv) ::= FOR LPAREN declaration(decl) expression_statement(cond) opt_expression(advance) RPAREN statement(body).
        { rv = dbcc_statement_new_for (decl, NULL, cond, advance, body);
          init = decl;
          cond = NULL;
          advance = NULL;
          body = NULL; }

jump_statement(rv) ::= GOTO IDENTIFIER(id) SEMICOLON.
        { rv = dbcc_statement_new_jump (id->v_symbol); }
jump_statement(rv) ::= CONTINUE SEMICOLON.
        { rv = dbcc_statement_new_continue (); }
jump_statement(rv) ::= BREAK SEMICOLON.
        { rv = dbcc_statement_new_break (); }
jump_statement(rv) ::= RETURN SEMICOLON.
        { rv = dbcc_statement_new_return (NULL); }
jump_statement(rv) ::= RETURN expression(expr) SEMICOLON.
        { rv = dbcc_statement_new_return (expr); expr = NULL; }

external_declaration_list(rv) ::= external_declaration(a).
        { rv.first = rv.last = a;
          a->next = NULL;
          a = NULL; }
external_declaration_list(rv) ::= external_declaration_list(tu) external_declaration(a).
        { rv = tu; tu = NULL;
          rv.last->next = a;
          a->next = NULL;
          rv.last = a;
          a = NULL; }

translation_unit(rv) ::= external_declaration_list(list).
        { rv = list; list.first = list.last = NULL; }

external_declaration(rv) ::= function_definition(f).
        { rv = f; f = NULL; }
external_declaration(rv) ::= declaration(d).
        { rv = d; d = NULL; }

// an DBCC_Declaration, even though it doesn't fit the mould too well
function_definition(fdef) ::= declaration_specifiers(decl_specs) declarator(decl) opt_declaration_list(kr) compound_statement(body).
        { ... 
          fdef = p_declaration_new_function_definition (...);
        }

// only used for k+r function definitions
declaration_list(x) ::= declaration(d).
        { d->next = NULL; x.first = x.last = d; }
declaration_list(rv) ::= declaration_list(in) declaration(d).
        { x.last->next = d; x.last = d; d->next = NULL; }

opt_declaration_list(rv) ::= .
        { rv.first = rv.last = NULL; }
opt_declaration_list(rv) ::= declaration_list(a).
        { rv = a; a.first = a.last = NULL; }
